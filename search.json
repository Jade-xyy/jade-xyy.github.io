[{"title":"Linux备忘","url":"/2025/04/03/Linux备忘/","content":"# Linux备忘\n## 系统简介及注意事项\n#### VMware安装虚机\n创建虚机最小628M内存挂起==暂停（真实操作系统没有挂起）\n\n真实机修改为硬盘启动 Boot->hard device\n\n密码复杂性原则：8位以上大小写字母、数字、符号；不能是英文单词；不能是和用户相关的内容\n\nswap应该分内存的2倍，但超过2G没有意义\n\n/root/install.log：存储安装在系统中的软件包机器版本信息\n/root/install.log.syslog：存储安装过程中留下的事件信息\n/root/anaconda-ks.cfg：以Kickstart配置文件的格式记录安装过程中设置的选项信息\n\n家目录root = /root\n普通用户=/home/用户名\n\nlo lookback 本机网卡\n\n临时修改网卡\nipifconfig eth0 ***.***.***.***\n\n#### 注意事项\n命令、文件、配置、用户名等全部都严格区分大小写\n \n所有的内容都是以文件形式保存\n\n不靠扩展名区分文件类型，靠文件属性，以下扩展名便于管理、约定俗成\n压缩包：.gz .bz2 .tar.bz2 .tgz\n二进制软件包：.rpm\n网页文件：.html .php\n脚本文件：.sh\n配置文件：.conf\n\n所有存储设备都必须挂载以后才能使用，包括硬盘、U盘、光盘\n\n#### 服务器管理和维护建议\nLinux各个目录的作用boot、etc目录可以备份下\n远程服务器不允许关机，只能重启\n重启时应该关闭服务（大量数据访问突然断电容易烧坏硬盘）\n不要在服务器访问高峰运行高负载命令\n远程配置防火墙时不要把自己踢出服务器\n指定合理的密码规范并定期更新\n合理分配权限\n定期备份重要数据和日志（etc、lib、var）\n\n\n## SELinux安全机制\nSecurity-Enhanced Linux\n美国NSA国家安全局主导开发，一套增强Linux系统安全的强制访问控制体系\n集成到Linux内核（2.6及以上）中运行\nSELinux体系针对用户、进程、目录和文件提供了预设的保护策略，以及管理工具\n#### 运行模式及切换\n运行模式：\nenforcing：强制\npermissive：宽松\ndisabled：彻底禁用\n\n查看运行模式：getenforce\n临时立即生效强制变宽松：setenforce 0\n临时立即生效宽松变强制：setenforce 1\n永久生效需重启系统：vim /etc/selinux/config SELINUX=disabled\n```bash\n# 安装2个排错软件包（yum provides \"semanage\"）\ndnf -y install policycoreutils-pyton-utils\n# 查找现在允许的端口：\nsemanage port -l | grep http\n# 增加需要放通的端口82（删除用-d）：\nsemanage port -a -t http_port_t -p tcp 82\n```\n\n## 防火墙\n防火墙有两种：firewalld（系统自带；底层调用的依然是iptables）、iptables\n#### 预设安全区域\n- 根据所在的网络场所区分，预设保护规则集\n    - -- public：进允许访问本机的sshd等少数几个服务（sshd、dhcp）\n    - -- trusted：允许任何访问\n    - -- block：阻塞任何来访请求（虽拒绝，但会给回应）\n    - -- drop：丢弃任何来访的数据包（直接丢弃，无回应）\n- 防火墙判定原则\n    - 查看客户端请求中来源IP地址，查看自己所有区域中规则，哪个区域中有该源IP地址规则，则进入该区域\n    - 如果所有区域都没找到，则进入默认区域（默认情况为public）\n\n\n#### 查看防火墙规则列表\n##### `… … … firewall … … … ∞`\n```bash\n# 检查是否安装\nrpm -q firewalld\n# 安装、启动\ndnf clean all ; dnf -y install firewalld\nsystemctl start firewalld\n# 查看当前区域规则（默认public）\nfirewall-cmd --list-all\n# 查看各个区域规则\nfirewall-cmd --list-all --zone=trusted\n                        --zone=block\n                        --zone=drop\n# 查看默认区域\nfirewall-cmd --get-default-zone\n# 默认public区域时，放行、移除http协议\ndnf -y install httpd;systemctl start httpd;访问ip（默认80端口）\nfirewall-cmd --add-service=http # 永久生效加 --permanent\nfirewall-cmd --list-all | grep services # 可以看到services（协议）的值多了http\n# 移除放行的http协议\nfirewall-cmd --remove-service=http\n# 放行、移除端口\nfirewall-cmd --add-port=80/tcp # 永久生效加 --permanent\nfirewall-cmd --list-all | grep ports\nfirewall-cmd --remove-port=80/tcp\n```\n\n## 命令（command）\n#### common命令\n命令格式：命令 [-选项] [参数]\n\n说明：个别命令使用不遵循此格式当有多个选项是，可以写在一起简化选项与完整选项 -a==--all\n#### 目录处理命令\n##### `… … … ls … … … ∞`\n```bash\n# 英文原意 list；所在路径 /bin/ls；执行权限 all\nls -a 查看全部\nls -l 长格式显示 long\nls -h 带单位显示\nls -d 显示当前目录本身\nls -i 显示文件对应i节点\nls -ldZ 显示SELinux访问权限\nls -Zld /var/www/html\nls -ldZ /webdev\n```\n##### `… … … mkdir … … … ∞`\n```bash\n# 英文原意 make directories；所在路径 /bin/mkdir；执行权限 all\nmkdir -p 递归创建\nmkdir *1 *2 *3 同时创建多个目录\n-m 指定权限，不指定m就按默认umask\nmkdir -m 750 /test\n```\n##### `… … … rmdir … … … ∞`\n```bash\n# 英文原意 remove empty directories；所在路径 /bin/rmdir；执行权限 all\nrmdir /test 删除空目录\n```\n##### `… … … cd … … … ∞`\n```bash\n# 英文原意 change directory；所在路径 shell内置；执行权限 all\ncd .. 回到上一级目录\n```\n##### `… … … pwd … … … ∞`\n```bash\n# 英文原意 print working directory；所在路径 /bin/pwd；执行权限 all\npwd 显示当前目录\n```\n##### `… … … cp … … … ∞`\n```bash\n# 英文原意 copy；所在路径 /bin/cp；执行权限 all\ncp [src1] [src2] [src3] [des] 把src123复制到des\ncp -rpcp -r 复制目录\ncp -p 保留文件属性\ncp /test /root/test1 复制test并改名为test1\n- a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。(复制的时候要保留文件属性用-a，不然会导致服务无法应用等问题，例如原文件拥有者为Oracle，直接cp后文件拥有者变为root，会导致数据库服务器无法使用，可以使用chown修\n改文件拥有者，或者复制的时候直接用cp -a命令)\n- d 拷贝时保留链接。\n- f 删除已经存在的目标文件而不提示。\n- i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。\n- p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。\n- r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。\n- l 不作拷贝，只是链接文件。\n```\n##### `… … … mv … … … ∞`\n```bash\n# 英文原意 move；所在路径 /bin/mv；执行权限 all\nmv [源文件或目录1] [源文件或目录2] [目标目录] 剪切文件、改名\n```\n##### `… … … rm … … … ∞`\n```bash\n# 英文原意 remove；所在路径 /bin/rm；执行权限 all\nrm -r [文件或目录] 删除目录\nrm -f 强制执行\n```\n#### 文件处理命令\n##### `… … … touch … … … ∞`\n```bash\n# 所在路径 /bin/touch；执行权限 all\ntouch test1 test2 创建空文件test1和test2\ntouch \"test1 test2\" 创建一个叫\"test1 test2\"的空文件（不建议这么用）\n```\n##### `… … … cat … … … ∞`\n```bash\n# 所在路径 /bin/cat；执行权限 all\ncat -n 显示行号\n```\n##### `… … … nl … … … ∞`\n```bash\n从第一行开始显示文件内容，并显示行号\n##### `… … … tac … … … ∞`\n```bash\n# 所在路径 /usr/bin/tac；执行权限 all\ntac 反向显示文件内容（上下颠倒）不支持-n参数\n```\n##### `… … … more … … … ∞`\n```bash\n# 所在路径 /bin/more；执行权限 all\nmore 分页显示文件内容\n（空格）or（f）翻页\n（Enter）换行\n（q）or（Q）退出\n```\n##### `… … … less … … … ∞`\n```bash\n# 所在路径 /usr/bin/less；执行权限 all\nless 分页显示文件内容\n（空格）or（f）翻页\n（pageup）向上翻页\n（↑）（↓）向上下翻1行\n（Enter）换行\n（q）or（Q）退出\n```\n##### `… … … head … … … ∞`\n```bash\n# 所在路径 /usr/bin/head；执行权限 all\nhead 默认显示文件前10行\nhead -n 20 显示文件前20行\n```\n##### `… … … tail … … … ∞`\n```bash\n# 所在路径 /usr/bin/tail；执行权限 alltail 默认显示后10行\ntail -n 指定行数\ntail -f 动态显示文件末尾内容\n```\n#### 链接命令\n##### `… … … ln … … … ∞`\n```bash\n# 英文原意 link；所在路径 /bin/ln；执行权限 all\nln -s [源文件] [目标文件] 创建软链接\nln -s /etc/issue /tmp/issue.soft 创建issue的软链接文件\nln /etc/issue /tmp/issue.hard 创建issue的硬链接文件\n# 软链接 == 快捷方式；文件权限全部为777（rwxrwxrwx）；可跨分区\n# 硬链接 == cp -p + 同步更新；i节点也相同；源文件丢失硬链接依然可以访问；硬链接不能跨分区；不可以针对目录使用\n# 1个文件一定有1个i节点，但是1个i节点不一定只对应1个文件，比如硬链接\n```\n#### 权限管理命令\n默认权限644，不具有可执行权限\n谁创建的文件谁就是文件的所有者；所属组就是文件创建者的缺省组\n##### `… … … umask … … … ∞`\n```bash\n# 英文原意 the user file-creation mask；所在路径 shell内置；执行权限 all\n# 缺省创建的文件不能有x权限\numask 权限掩码，实际值=777-显示值\numask -S 以rwx形式显示新建文件缺省权限\numask 023 修改新建文件默认权限为rwxrx-r--\n# 永久修改 /etc/login.defs UMASK\n```\n##### `… … … chmod … … … ∞`\n```bash\n# 英文原意 change the permissions mode of a file；所在路径 /bin/chmod； 执行权限 all\nchmod [{ugoa}{+-=}{rwx}] [文件或目录] 改变文件或目录的权限\n [mode=421] [文件或目录]chmod -R 递归修改\nchmod u+x test.txt 所属用户增加执行权限\nchmod g+w,o-r test.txt 所属组增加写权限，其他人减读权限\nchmod g=rwx test.txt 所属组改为rwx权限\nchmod 640 test.txt 修改所属用户为读写、所属组为读、其他无权限\nchmod -R 777 /test 递归修改目录及以下文件的全部权限\n# 目录的rx权限一定是并存的\n# 目录的w权限，对目录及以下内容有w权限；即使普通用户没有文件的w权限，但所在目录有权限，即可删除\nchmod +x /usr/bin/kubectl\n```\n##### `… … … chown … … … ∞`\n```bash\n# 英文原意 change file ownership；所在路径 /bin/chown；执行权限 root\nchown [用户] [文件或目录] 改变文件或目录的所有者\nuseradd jade 添加名为jade的用户\nchown jade test.txt 改变test.txt的所有者为jade\n# 在root下才能执行\n```\n##### `… … … chgrp … … … ∞`\n```bash\n# 英文原意 change file group ownership；所在路径 /bin/chgrp；执行权限 all\nchgrp [用户组] [文件或目录]\ngroupadd jadegroup 添加名为jadegroup的组\nchgrp jadegroup test.txt 改变test.txt文件的所属组为jadegroup\n```\n##### `… … … chcon … … … ∞`\n```bash\ngetenforce查看SELinux是打开模式情况下\nls -Zld /var/www/html/ 可以看到对应的标签\nchcon -R -t httpd_sys_content_t /webdev\nls -Zld /webdev\n```\n\n#### 文件搜索命令\n##### `… … … find … … … ∞`\n```bash\n详见四剑客之find节点\n```\n##### `… … … locate … … … ∞`\n```bash\n# 所在路径 /usr/bin/locate；执行权限 all\nlocate test.txt 在文件资料库中查找文件\n# 维护的资料库在/var/lib/mlocate/mlocate.db；系统会定时更新资料库；资料库不包括/tmp；可节省系统资源\nupdatedb 手动更新文件资料库\nlocate -i Test.txt 不区分大小写\n```\n##### `… … … which … … … ∞`\n```bash\n# 所在路径 /usr/bin/which；执行权限 all\nwhich 命令\nwhich ls 搜索命令所在目录及别名信息\n```\n##### `… … … whereis … … … ∞`\n```bash\n# 所在路径 /usr/bin/whereis；执行权限 all\nwhereis ls 搜索ls所在目录及帮助文档路径\n```\n##### `… … … grep … … … ∞`\n```bash\n详见四剑客之grep节点\n帮助命令\n```\n##### `… … … man … … … ∞`\n```bash\n# 英文原意 manual；所在路径 /usr/bin/man；执行权限 all\nman [命令或配置文件]\nman ls 查看ls命令的帮助信息\n# 第一行NAME是命令作用；:/-l定位到对应参数\nman services 查看配置文件的帮助；不能加绝对路径，直接加配置文件名\nman 5 passwd 查看配置文件passwd的帮助；1 命令的帮助 5 配置文件的帮助\nman date\n\n类似man命令\nwhatis ls 获得命令的简短帮助信息\napropos 查看配置文件的简短帮助信息\ninfo 等价man，支持跳转\n命令 --help 列出命令主要选项\n```\n##### `… … … help … … … ∞`\n```bash\n# 所在路径 shell内置命令；执行权限 all\nhelp 获得shell内置命令的帮助信息；找不到路径的命令就是shell内置命令\nhelp umask 查看umask命令的帮助信息\nhelp if\n```\n#### 用户管理命令\n##### `… … … useradd … … … ∞`\n```bash\n# 所在路径 /usr/sbin/useradd；执行权限 root\nuseradd jade 添加新用户\n```\n##### `… … … passwd … … … ∞`\n```bash\n# 所在路径 /usr/bin/passwd；执行权限 all\npasswd jade 设置用户名密码\npasswd 更改当前用户的密码\npasswd --stdin testuser1\n# root可以更改任何人的密码，普通用户只能改变自己的密码\n```\n##### `… … … who … … … ∞`\n```bash\n# 所在路径 /usr/bin/who；执行权限 all\nwho 查看登录用户信息\n# tty 表示 本地终端；pts 表示 远程终端\n```\n##### `… … … w … … … ∞`\n```bash\n# 所在路径 /usr/bin/w；执行权限 all\nw 查看登录用户详细信息\n# IDLE 空闲时间；JCPU 累计占用cpu时间；PCPU 当前执行操作占用的cpu时间；WHAT 当前正在执行的命令\n```\n##### `… … … compgen … … … ∞`\n```bash\n# 查看用户\ncompgen -u # bash内置命令，查看所有用户\n```\n\n#### 压缩解压命令\n压缩格式 .gz .zip(不需要装对应软件、自带) .rar\n##### `… … … gzip/gunzip … … … ∞`\n```bash\n# 英文原意 GNU zip/unzip；所在路径 /bin/gzip gunzip；执行权限 all\ngzip 压缩后缀.gz\ngunzip test.gz <==> gzip -d test.gz 解压缩.gz的压缩文件\n# gzip只能压缩文件，不能压缩目录；压缩完不保留源文件\n```\n##### `… … … tar … … … ∞`\n```bash\n# 所在路径 /bin/tar；执行权限 all\ntar [压缩后文件名] [目录]\n-c 打包\n-C 指定解包路径\n-x 解包\n-v 显示详细信息\n-f 指定文件名，此选项要在其他选项的最后边\n-z -j -J 压缩/解压缩，.gz .bz2 .xz格式\n-t 显示包中的文件清单\n-P 以绝对路径方式进行归档压缩\n\ntar -zcf test.tar.gz mulu 打包压缩\ntar -zxvf test.tar.gz 解压缩\ntar -cf 打包\ntar -xf  -C /tmp  解压到指定目录\n```\n压缩格式\t扩展名\t特点\ngzip\t.gz\t速度快，压缩比例低\nbzip2\t.bz2\t速度中等，压缩比例中等\nxz\t.xz\t速度慢，压缩比例高\n##### `… … … zip/unzip … … … ∞`\n```bash\n# 所在路径 /usr/bin/zip unzip；执行权限 all\nzip [压缩后文件名] [文件/目录]-r 压缩目录\nzip test.zip test 压缩文件\nzip -r mulu.zip mulu 压缩目录\nunzip test.zip 解压缩，不区分文件或目录\n# 保留源文件；压缩比80%\n```\n##### `… … … bzip2 … … … ∞`\n```bash\n# 所在路径 /usr/bin/bzip2；执行权限 all\nbzip2 [文件]\n-k 产生压缩文件后保留源文件\nbzip2 -k mulu 生成后缀.bz2打包压缩文件\ntar -cjf mulu.tar.bz2 mulu 用tar压缩成bz2后缀文件\ntar -xjf mulu.tar.bz2 解压\n```\n#### 网络命令\n##### `… … … write … … … ∞`\n```bash\n# 所在路径 /usr/bin/write；执行权限 all\nwrite <用户名> 给用户发信息；ctrl+backspace删除；ctrl+d保存结束\n# 所有用户登录在当前服务器才能互发信息，在线用户\n```\n##### `… … … wall … … … ∞`\n```bash\n# 英文原意 write all；所在路径 /usr/bin/wall；执行权限 all\nwall [message] 发广播信息# 给当前在线的所有用户发信息\n```\n##### `… … … mail … … … ∞`\n```bash\n# 英文原意 write all；所在路径 /usr/bin/wall；执行权限 all\nwall [message] 发广播信息# 给当前在线的所有用户发信息\n```\n##### `… … … ping … … … ∞`\n```bash\n# 所在路径 /bin/ping；执行权限 all\nping IP 测试网络连通性\n-c 指定发送次数\n# packet loss 丢包率\n```\n##### `… … … telnet … … … ∞`\n```bash\ntelnet ip port\nctrl+]退出\n```\n##### `… … … ifconfig … … … ∞`\n```bash\n# 英文原意 interface configure；所在路径 /sbin/ifconfig；执行权限 root\nifconfig 网卡名称 IP信息\nifconfig 查看网卡信息；eth0 本地真实网卡信息；lo 本机通信测试用的\nifconfig eth0 11.0.1.6 设置网卡信息\n```\n##### `… … … ip … … … ∞`\n```bash\n```\n\n\n\n\n##### `… … … last … … … ∞`\n```bash\n# 所在路径 /usr/bin/last；执行权限 all\nlast 列出目前与过去登入系统的用户信息\n```\n##### `… … … lastlog … … … ∞`\n```bash\n# 所在路径 /usr/bin/lastlog；执行权限 all\nlastlog 检查全部用户上次登录的时间\nlastlog -u 502 检查特定用户上次登录时间\n```\n##### `… … … traceroute … … … ∞`\n```bash\n# 所在路径 /bin/traceroute；执行权限 all\ntraceroute www.sinna.com.cn 显示数据包到主机间的路径\n```\n##### `… … … netstat … … … ∞`\n```bash\n# 所在路径 /bin/netstat；执行权限 all\nnetstat [选项] 显示网络相关信息\n-t TCP协议\n-u UDP协议\n-l 监听\n-r 路由\n-n 显示IP地址和端口号\nnetstat -tlun 查看本机监听的端口\nnetstat -an 查看本机所有的网络连接\nnetstat -rn 查看本机路由表\n# ss和netstat效率对比\ntime netstat -at\ntime ss\n```\n##### `… … … ss … … … ∞`\n```bash\n#获取socket统计信息，显示更多更详细的TCP连接状态的信息，且比netstat更快速高效\nss -antpl\n-n --numeric 不解析服务名称\n-r --resolve 解析主机名\n-l --listening 显示监听状态的套接字（sockets）\n-a --all 显示所有套接字\n-o --options 显示计时器信息\n-e --extended 显示详细的套接字（socket）的内存使用情况\n-p --processed 显示使用套接字的进程\n-i --info 显示tcp内部信息\n-s --summary 显示套接字（socket）使用概况\n-4 --IPv4 仅显示IPv4的套接字\n-6\n-0 --packet 显示PACKET套接字\n-t --tcp 仅显示TCP套接字\n-u --udp 仅显示UDP套接字\n-d --dccp 仅显示DCCP套接字\n-w --raw 仅显示RAW套接字\n-x --Unix 仅显示Unix套接字\n-f --family=FAMILY显示FAMILY类型的套接字，FAMILY可选Unix、inet、inet6、link、netlink\n-A --query=QUERY, --socket=QUERY\nQUERY:={all| inet| tcp| udp | raw | unix | packet | netlink } [QUERY]\n-D --diag=FILE将原始TCP套接字信息转储到文件\n-F --filter=FILE从文件中都去过滤信息\nFLITER:=[ stateTCP-STATE ] [ EXPRESSION ]\n```\n##### `… … … setup … … … ∞`\n```bash\n# 所在路径 /usr/bin/setup；执行权限 all\nsetup 配置网络 # redhat专有，图形化界面设置\nservice network restart # 设置后重启网络\n```\n##### `… … … mount … … … ∞`\n```bash\n# 所在路径 /bin/mount；执行权限 all\nmount [-t 文件系统] 设备文件名 挂载点\nmount -t iso9660 /dev/sr0或cdrom /mnt/cdrom/\numount /dev/sr0\n```\n#### 关机重启命令\n##### `… … … shudown … … … ∞`\n```bash\n# 所在路径 //；执行权限\nshutdown [选项] 时间\n-c 取消前一个关机命令\n-h 关机\n-r 重启\nshutdown -h now 现在关机\nshutdown -h 20:30 下午八点半关机\n# 其他关机命令\nhalt\npoweroff # 相当于直接断电\ninit 0\n# 其他重启命令\ninit 6\nreboot\n```\n系统运行级别\n0 关机\n1 单用户\n2 不完全多用户，不含NFS服务\n3 完全多用户\n4 未分配\n5 图形界面\n6 重启\n查看系统运行级别\ncat /etc/inittab\nrunlevel\n\nlogout or ctrl+d 退出登录\n \n#### 四剑客之sed\n##### `… … … sed … … … ∞`\n```bash\n# 轻量级流编辑器-数据的增删改查替换sed\nsed [选项] '[动作]' 文件名\n选项：\n-n：只输出经过sed处理的行，不修改\n-e：允许对输入数据 应用多条sed命令\n-i：sed的修改结果直接修改到文件动作：\na \\：追加，在当前行后添加1行或多行；多行时除最后一行外，每行末需要用\\代表数据未完结\nc \\：行替换，用c后面的字符串替换原数据行；替换多行时除最后一行外，每行末需要用\\代表数据未完结\ni \\：插入，在当前行前添加1行或多行；多行时除最后一行外，每行末需要用\\代表数据未完结\nd：删除，删除指定的行\np：打印，输出指定的行\ns：字串替换，格式“行范围s/旧字串/新字串/g”\n\n# 查看文件的第2行\nsed -n '2p' testfile.txt\n\n# 删除第2行到第4行的数据，但不修改文件本身\nsed '2,4d' testfile.txt\n\n# 在第2行后追加hello\nsed '2a hello' testfile.txt\n\n# 在第二行前插入两行数据\nsed '2i hello \\world' testfile.txt\n\n# 数据替换\nsed '2c tihuan' testfile.txt\n\n# 字符串替换\n# 替换第3行的old为new并写入\nsed '3s/old/new/g' testfile.txt\n# 同时替换old1 old2为空\nsed -e 's/old1//g;s/old2//g' testfile.txt\n# 找到expr开头的行，左花括号后插入job字段\nsed -i '/expr/s/{/{job!~\\\\\"k8s-(.*)-prometheus\\\\\"/g' grafana.txt\n```\n\n#### 四剑客之awk字符截取\n##### `… … … cut … … … ∞`\n```bash\ncut [选项] 文件名\n-f n：提取第n列\n-d 分隔符：按照指定分隔符分隔列\n# 仅限制表符、分隔符，空格不适用\n# 根据:分隔提取第1、3列\ncut -d \":\" -f 1,3 testfile.txt \n错误示例：df -h | cut -d \" \" -f 5  提取出来的是空格\n```\n##### `… … … printf … … … ∞`\n```bash\nprintf '输出类型输出格式' 输出内容\n输出类型：\n%ns：输出字符串（n指代输出几个字符）\n%ni：输出整数（n指代输出几个数字）\n%m.nf：输出浮点数（m、n是数字，指代输出的整数位数和小数位数，如%8.2f代表共输出8位，6位整数2位小数）\n输出格式：\n\\a：输出警告声音\n\\b：输出退格键\n\\f：清屏\n\\n：换行\n\\r：回车\n\\t：水平输出Tab键\n\\v：垂直输出Tab键\n\nprint：会在每个输出后自动加入1个换行符，linux默认没有print\nprintf：是标准格式输出命令，并不会自动加入换行符，需手工加入换行符\n```\n##### `… … … awk … … … ∞`\n```bash\nawk '条件1{动作1} 条件2{动作2}…' 文件名\n条件（Pattern）：一般用关系表达式作为条件，如>、>=、<=\n动作（Action）：格式化输出；流程控制语句\n\n# 处理文本，将文本按照指定的格式输出\n# 数据过滤 数据处理 数据统计\nNF 最后一列\nNR 行号 从1开始，新的文件延续上面的计数，新文件不从1开始\nFNR 读取文件的记录数（行号），从1开始，新的文件重新从1开始计数\nFS 输入字段分隔符，默认是空格\nOFS 输出字段分隔符 默认也是空格\nRS 输入行分隔符，默认为换行符\nORS 输出行分隔符，默认为换行符\n\nawk '{print $1,$NF}'\n\n# 索引1到5个字符\nawk '{print substr($0,1,5)}'\n\n# 跳过行首空格，输出第1个字符\nawk '{sub(/^[ ]*/,\"\");print substr($0,1,1)}'\n\n# 用printf打印表格\nawk -F: '{printf \"|%-15s| %-10s| %-15s|\\n\", $1,$2,$3}' /etc/passwd\n\n# 内置变量FS 以什么为分隔符\ncat /etc/passwd | grep \"/bin/bash\" | awk 'BEGIN {FS=\".\"} {printf $1 \"\\t\" $3 \"\\n\"}'\n\n# 统计第一列字符的最大个数\nawk -F: 'BEGIN{num=0}{if(length($1)>num){num=length($1)}}END{print num}' /etc/passwd\n\n# 输出第一列最后一列排列整齐\nawk -F: '{printf \"%-15s %s\\n\",$1,$NF}' /etc/passwd\n\n# 打印奇数行\nawk '{if(NR%2){print NR,$0}}' /etc/passwd\n\n# 打印偶数行\nawk '{if(NR%2==0){print NR,$0}}' /etc/passwd\n\n# 打印偶数行中包含bash的行\nawk '/bash/ {if(NR%2==0){print NR,$0}}' /etc/passwd\n\n# 在行首输出“奇/偶数行 行号”\nawk '{if(NR%2){printf \"奇数行: %d %s\\n\",NR,$0}else{printf \"偶数行: %d %s\\n\",NR,$0}}' /etc/passwd\n\n# 在第1、3行前输出行号\nawk '{if(NR==1){print \"1\",$0}else if (NR==3){print NR,$0} else{print $0}}' /etc/passwd\n\n# 统计/etc/nginx/nginx.conf中所有词的个数\negrep -o \"[a-zA-Z0-9]+\" /etc/nginx/nginx.conf | awk '{if(arr[$1]){arr[$1]++}else{arr[$1]=1}}END{for(i in arr){printf \"%-20s %d\\n\",i,arr[i]}}'egrep -o \"[a-zA-Z0-9]+\" /etc/nginx/nginx.conf | awk '{arr[$1]++}END{for(i in arr){printf \"%-20s %d\\n\",i,arr[i]}}'\n\n# 统计/etc/fstab中以#开头的行中 词的个数\negrep '^ *#' /etc/fstab | egrep -o \"[a-zA-Z0-9]+\" | awk '{arr[$1]++}END{for(i in arr){printf \"%-20s %d\\n\",i,arr[i]}}'\n\n# 统计/etc/passwd中每个解析器的用户数\nawk -F: '{arr[$NF]++}END{for(i in arr){print i,arr[i]}}' /etc/passwd\n\n# 使用stat打印数字权限\nstat 1.txt | egrep \"Uid\" | awk -F/ '{print $1}' | awk 'BEGIN{FS=\"\"}{print $6,$7,$8}'\n\n# 使用ll打印数字权限\nll 1.txt | awk '{print $1}' | awk 'BEGIN{FS=\"\"}{if($2==\"r\"){u+=4} if($3==\"w\"){u+=2} if($4==\"x\"){u+=1} if($5==\"r\"){g+=4} if($6==\"w\"){g+=2} if($7==\"x\"){g+=1} if($8==\"r\"){o+=4} if($9==\"w\"){o+=2} if($10==\"x\"){o+=1}} END{print u,g,o}'\n\n# while 每行打印3遍\nawk '{i=0;while(i<3){print $0;i++}}' /etc/passwd\n\n# 打印第10行的全部列-for\nawk -F: 'NR==10{for(i=1;i<=NF;i++){print $i}}' /etc/passwd\n\n# 打印第10行的全部列-while\nawk -F: 'NR==10{i=1;while(i<=NF){print $i;i++}}' /etc/passwd\n\n# 获取月是Jul 日>20的行\ncat secure* | grep Accept | awk -F\" \" '{if($1==\"Jul\" &amp;&amp; $2>20){print $0}}'\n\nawk '$2 ~ /ia/ {print $0}'\n\n# 获取k8s节点内存占用超过90的节点\nkubectl top node | awk '/[0-9]+/{if($NF>=90){print}}'\n\n# 获取节点总内存\nkubectl get nodes -o jsonpath='{.items[*].status.capacity.memory}' | awk '{sum+=$1} END {print sum/1024/1024 \" MB\"}'\n\n# 获取每台的可分配内存并以换行结尾\nkubectl get nodes -o jsonpath=\"{range .items[*]}{.metadata.name}{'\\t'}{.status.capacity.memory}{'\\t'}{.status.allocatable.memory}{'\\n'}{end}\" | awk '{print $1 \" \" $2/1024 \"MB \" $3/1024/1024 \"MB\"}'\n```\n \n\n#### 四剑客之grep\n##### `… … … grep … … … ∞`\n```bash\n# 所在路径 /bin/grep；执行权限 all；针对文件内容，输出包含指定字符串的行\ngrep [选项] [查找条件] 目标文件\ngrep -i：忽略大小写\ngrep -v：排除指定字串\ngrep -v ^# test.sh：排除以#开头的行；^标识行首\ngrep --color=auto：搜索出的关键字用颜色显示\n# 常用选项：-i -v\n# 常用查找条件：\n^ 以什么开头\n$ 以什么结尾\n^$ 标识空行\n获取有效信息（过滤空行、注释）：grep -Ev '^$|^#' /etc/login.defs\ngrep -C 50 \"MQ开始推送云策\"\ngrep -C 50 \"860523323848888321\"\ngrep -C 50 \"14:12\"\n```\n\n#### 四剑客之find\n##### `… … … find … … … ∞`\n```bash\n# 精确查找文件\n# 查找过程中如果遇到/proc目录下的报错，属于正常现象，因为/proc不占用磁盘空间，占用的是内存空间\nfind [查找目录] [条件]\n-type：按类型查找（f、d、l）\n-name：按文档名称查找\n-size：按文件大小查找（k、M、G）\n查找大于2M的：find /boot -size +2M\n查找小于1M的：find /boot -size -1024K（-1M是bug查不出来）\n-user：按文件所有者查找\n-perm：按文件权限查找\n\t查找包含SGID的：find /usr/ -perm -g=s\n\t查找就是SGID的：find /usr/ -perm g=s\n\t查找不包含的：find /usr/ -perm /g=s\n    查找当前目录下权限不是644的php文件：find . -type f -name \"*.php\" ! -perm 644\n-mtime：按修改时间查找\n\t查找近10天修改的文件：find /etc -mtime -10\n\t查找10天前：find /etc/ -mtime +10\n# 多条件查找\n连接符：\n-a <==> &&（默认-a，可省略不写）\n-o <==> ||\n\n# 处理查找到的内容\nfind [目录] [条件] -exec 处理命令 {} \\;\n{} 标识find查找到的每一个结果，\\; 标识操作结束\n#  拷贝前findfiles目录需要存在，否则会出现findfiles文件\nfind /boot/ -name \"vm*\" -exec cp -r {} /root/findfiles \\;\n```\n##### `… … … join … … … ∞`\n```bash\n# 获取ecm节点总内存、k8s分配内存、内存占比\njoin -1 1 -2 1 <(kubectl get nodes -o jsonpath=\"{range .items[*]}{.metadata.name}{'\\t'}{.status.capacity.memory}{'\\t'}{.status.allocatable.memory}{'\\n'}{end}\" | grep ecm |awk '{if(index($3,\"Ki\")>0){print $1 \" \" $2/1024 \"Mi \" $3/1024 \"Mi\"}else{print $1 \" \" $2/1024 \"Mi \" $3/1024/1024 \"Mi\"}}') <(kubectl top node | grep ecm | awk '{print $1,$4,$5}') | awk 'BEGIN{print \"节点\",\"总内存\",\"k8s分配内存\",\"已使用内存\",\"使用内存占比\"}{print}'\n\n# 以第一个命令的第一个串儿为key，以第二个命令的第一个串儿为key，两个命令需排过序\njoin -1 1 -2 1\n```\n#### vim\n```bash\n# 建立、编辑、显示文本文件\n命令模式 -> esc进入命令模式\n插入模式 -> 命令按i a o进入插入\n编辑模式 -> 命令模式输:\n\n# 命令模式\nA 跳入行末进入编辑\nI 跳到行首进入编辑\no 光标所在下一行进入编辑\nO 光标所在上一行进入编辑\n\n0 跳到行首 \n$ 跳到行尾\ngg 跳到首行\nG 跳到尾行\nnG 跳到第n行\nu 撤销\nctrl r 恢复撤销\nd$ 删到行尾\nD 删到行尾\nn + x 删除n个字符\n\nndd 删除光标所在的向下n行\nd1G 删除光标所在到第一行\ndG 删除光标所在到最后一行\nd0 删除光标所在到该行最前面的一个字符\nx 相当于backspace\nX 相当于delete\nnx 连续向后删除n个字符\nyy 复制当前行\np 粘贴到光标所在行下\nP 粘贴到贯标所在行上\nnyy 复制当前行到向下n行\ndd 剪切当前行\nndd 剪切当前行以下n行\nr 替换当前字符\nR 光标所在处替换，直到esc退出\nZZ 保存修改并退出快捷键\n\n# 编辑模式\n:set nu 显示行号\n:n 跳到第n行\n:n1,n2d 删除指定范围的行\n:%s/old/new/g 全文替换指定字符串；结尾的g不询问直接替换，c询问\n:n1,n2s/old/new/g 在一定范围内替换指定字符串\n:n1,n2s/^/#/g 连续行注释；^标识行首\n:n1,n2s/^#//g 连续行替换注释为空\n:n1,n2s/^/\\/\\//g 连续航添加//注释；\\转义符\n:set ff?   查看当前文本格式\n:set ff=unix  设置为unix格式\n\n查找按/\nn 向下查找\nN 向上查找\n\n:w 保存修改\n:w new_filename 另存为指定文件\n:wq 保存修改并退出\n:q! 不保存退出\n:wq! 强制保存修改并退出（文件所有者及root可使用）\n\n:r 文件名 # 导入文件内容到光标所在行\n:! 命令 # 不退出vim执行命令\n:r !date # 导入命令执行结果到光标所在行\n:map ^P I#<ESC> 跳到行首并进入插入模式并插入\"#\"；^P用ctrl+v+p输入\n:map ^B 0x 跳到行首，删除行首第一个字符\n:map ^H helloworld 插入helloworld\n:ab mymail 281108530@qq.com 替换mymail为邮箱\n\n/$HOME/.vimrc 快捷键放到配置文件里，重启不失效\n```\n\n\n#### shell命令\n##### `… … … date … … … ∞`\n```bash\n%I 小时，12小时制（01~12）\n%k 小时，24小时制（0~23）\n%l 小时，12小时制（1~12）\n%M 分钟（00~59）\n%p 显示出AM或PM\n%r 显示时间，12小时制（hh:mm:ss %p）\n%s 从1970年1月1日00:00:00到目前经历的秒数\n%S 显示秒（00~59）\n%T 显示时间，24小时制（hh:mm:ss）\n%X 显示时间的格式（%H:%M:%S）\n%Z 显示时区，日期域（CST）\n%a 星期的简称（Sun~Sat）\n%A 星期的全称（Sunday~Saturday）\n%h,%b 月的简称（Jan~Dec）\n%B 月的全称（January~December）\n%c 日期和时间（Tue Nov 20 14:12:58 2012）\n%d 一个月的第几天（01~31）\n%x,%D 日期（mm/dd/yy）\n%j 一年的第几天（001~366）\n%m 月份（01~12）\n%w 一个星期的第几天（0代表星期天）\n%W 一年的第几个星期（00~53，星期一为第一天）\n%y 年的最后两个数字（1999则是99）\n```\n##### `… … …  加减操作 … … … ∞`\n```bash\n# 显示当前年月日\ndate +%Y%m%d\n# 显示前一天的日期\ndate -d “+1 day” +%Y%m%d\n# 显示后一天的日期\ndate -d “-1 day” +%Y%m%d\n# 显示上一月的日期\ndate -d “-1 month” +%Y%m%d\n# 显示下一月的日期\ndate -d “+1 month” +%Y%m%d\n# 显示前一年的日期\ndate -d “-1 year” +%Y%m%d\n# 显示下一年的日期\ndate -d “+1 year” +%Y%m%d\n# 2秒后输出\ndate -d “2 second” +\"%Y-%m-%d %H:%M.%S\"\n# 时间戳转换时间date\ndate -d @时间戳\ndate -d \"1970-01-01 时间戳 days\"\n# 时间转时间戳\necho $(($(date --date=\"2022/12/09\" +%s)/86400+1))\n```\n##### `… … … curl … … … ∞`\n```bash\n#获取汽油价格json格式化\ncurl -shttps://api.help.bj.cn/apis/youjiajq\n#获取汽油价格 数组\ncurl -shttps://api.help.bj.cn/apis/youjia| jq .data[1][1]\n#查看IP\ncurl myip.ipip.net\n\ncurl -I -s --connect-timeout 5 -m 5 -w \"%{http_code}\" -o /dev/null -u ${user}:${pass}://${ip}/root/.kube\n```\n \n\n\n## 软件包管理\n#### 软件包分类\n源码包（脚本安装包）\n优点：开源；可自由选择所需功能；软件编译安装，更加稳定效率更高；卸载方便\n缺点：安装过程步骤多、容易出现拼写错误；编译过程时间长，比二进制长；安装过程报错较难解决\n\n二进制包（RPM包、系统默认包）\n优点：安装简单；比源码包速度快\n缺点：不能看到源代码；功能选择不如源码包灵活；依赖性，需要依赖别的包\n#### RPM包管理 - rpm命令管理\nRPM包命名原则\nhttpd-2.2.15-15.el6.centos.1.i686.rpm\nhttpd  软件包名\n2.2.15  软件版本\n15  软件发布的次数\nel6.centos  适合的Linux平台\ni686  适合的硬件平台rpm  \nrpm包的扩展名\n\nRPM包依赖性\n树形依赖：a->b->c\n环形依赖：a->b->c->a\n模块依赖：查询网站 www.rpmfind.net\n\nRPM命令管理\n包全名：操作的包是未安装的软件包时，使用包全名，而且要注意路径\n包名：操作已安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库\n##### `… … … rpm安装 … … … ∞`\n```bash\nrpm -ivh 包全名\n-i (install)  # 安装\n-v (verbose)  # 显示详细信息\n-h (hash)  # 显示进度\n--nodeps  # 不检测依赖性\n```\n##### `… … … rpm包升级 … … … ∞`\n```bash\nrpm -Uvh 包全名\n-u (upgrade)  # 升级\n```\n##### `… … … rpm包卸载 … … … ∞`\n```bash\nrpm -e 包名\n-e (erase)  # 卸载\n--nodeps  # 不检查依赖性\n```\n##### `… … … rpm查询 … … … ∞`\n```bash\nrpm -qa\n-q (query)  # 查询包是否安装\n-a (all)  # 查询所有已经安装的rpm包\n\n# 查询包详情，未安装的包用全名\nrpm -qi 包名\n-i (information)  # 查询软件信息\n-p (package)  # 查询未安装包信息\n\n# 查询包中文件安装位置，未安装的包用全名\nrpm -ql 包名\n-l (list)  # 列表\n-p (package)  # 查询未安装包信息，查询打算装的位置\n\n# 查询系统文件属于哪个软件包\nrpm -qf 系统文件名\n-f (file)\n\n# 查询软件包的依赖性\nrpm -qR 包名\n-R (requires)  # 查询软件包的依赖性\n-p (package)  # 查询未安装包信息\n```\n##### `… … … rpm包校验 … … … ∞`\n```bash\nrpm -V 已安装的包名\n-V (verify)  # 校验指定RPM包中的文件\n\n# 验证内容中的8个信息的具体内容，未改变的显示\".\"\nS # 文件大小是否改变\nM # 文件的类型或文件的权限（rwx）是否被改变\n5 # 文件MD5校验和是否改变（可以堪称文件内容是否改变）\nD # 设备的中，从代码是否改变\nL # 文件路径是否改变\nU # 文件的属主是否改变\nG # 文件的属组是否改变\nT # 文件的修改时间是否改变\n\n# 文件类型\nc # 配置文件（config file）\nd # 普通文档（documentation）\ng # “鬼”文件，很少见，意思该文件不应该被这个rpm包包含（ghost file）\nl # 授权文件（license file）\nr # 描述文件（read me）\n```\n##### `… … … rpm包中文件提取 … … … ∞`\n```bash\nrpm2cpio 包全名 | cpio -idv .文件绝对路径\n\nrpm2cpio  # 将rpm包转换为cpio格式\ncpio  # 是一个标准工具，用户创建软件档案文件和从档案文件中提取文件\n\ncpio 选项 < [文件|设备]\n-i  # copy-in模式，还原\n-d  # 还原时自动新建目录\n-v  # 显示还原过程\n```\n#### RPM包管理 - yum在线管理\nredhat需要付费才能使用yum，centos免费\n```bash\n## IP地址配置\n# redhat用setup\n1.启动网卡\nvim /etc/sysconfig/network-scripts/ifcfg-eth0\n改为ONBOOT=\"yes\"\n\n2.重启网络服务\nservice network restart\n\n## 网络yum源\nvim /etc/yum.repos.d/CentOS-Base.repo\n[base]  # 容器名称\nname  # 容器说明，可以随便填\nmirrorlist  # 镜像站点，可注释\nbaseurl  # yum源服务器的地址。默认时CentOS官方的yum源服务器，也可改为其他yum源地址\nenabled  # 此容器是否生效，=1 or 不写为生效 =0为不生效\ngpgcheck  # 1为RPM的数字证书生效 0为不生效\ngpgkey  # 数字证书的公钥文件保存位置，无需修改\n```\n##### `… … … yum 查询 … … … ∞`\n```bash\n# 查询所有可用软件包列表\nyum list\n\n# 搜索服务器上所有和关键字相关的包\nyum search 关键字\n```\n##### `… … … yum 安装 … … … ∞`\n```bash\nyum -y install 包名\ninstall  # 安装\n-y  # 自动回答yes\n```\n##### `… … … yum 升级 … … … ∞`\n```bash\nyum -y update 包名  # 不加包名是升级所有包，慎用\nupdate  # 升级\n-y  # 自动回答yes\n```\n##### `… … … yum 卸载 … … … ∞`\n```bash\nyum -y remove 包名  # 尽量不卸载\nremove  # 卸载\n-y  # 自动回答yes\n```\n##### `… … … yum 软件组 … … … ∞`\n```bash\n# 列出所有可用的软件组列表\nyum grouplist\n\n# 安装指定软件组，组名可以由grouplist查询出来\nyum groupinstall 软件组名  # 有空格用\"\"\n\n# 卸载指定软件组\nyum groupremove 软件组名\n\n## 光盘yum源搭建\n1.挂载光盘\nmount /dev/cdrom /mnt/cdrom/\n2.2.让网络yum源文件失效\ncd /etc/yum.repos.d/\nmv CentOS-Base.repo CentOS-Base.repo.bak\nmv CentOS-Debuginfo.repo CentOS-Base.repo.bak\nmv CentOS-Vault.repo CentOS-Vault.repo.bak\n3.修改光盘yum源文件\nvim CentOS-Media.repo\n[c6-media]name=CentOS-$releasever - Media\nbaseurl=file:///mnt/cdrom\n# 地址为自己的光盘挂载地址\n#        file:///media/cdrom/\n#        file:///media/cdrecorder/\n# 注释这两个不存在的地址\ngpgcheck=1\nenabled=1\n# 把enabled=0改为enabled=1，让这个yum源配置文件生效gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6\n```\n#### 源码包脚本安装包\n- 源码包和rpm包的区别\n安装前：源码包是开源的\n安装后：安装位置不通\n\n- 安装位置不同带来的影响：\nrmp包安装的服务可以使用系统服务管理命令(service)来管理，例如rpm包安装的apache的启动方法：\n/etc/rc.d/init.d/httpd start\nservice httpd start\n源码包安装的服务则不能被service管理，因为没有装到默认路径中，所以只能用绝对路径进行服务的管理\n/usr/local/apache2/bin/apachectl start\n\n- 源码包安装过程\n```bash\n1.安装准备\n# 安装C语言编译\nrpm -q gcc\n# 下载源码包\nhttp://mirror.bit.edu.cn/apache/httpd/\n2.安装注意事项\n# 源代码保存位置：/usr/local/src/\n# 软件安装位置：/usr/local/\n# 如何确定安装过程报错：安装过程停止、并出现error、warning或no的提示\n3.开始安装\n# 解压缩下载的源码包、进入解压缩目录\n# 查看说明文件里的安装步骤\ncat INSTALL 或者 cat README\n./configure --prefix=/usr/local/apache2  # 软件配置与检查\n定义需要的功能选项\n检测系统环境是否符合安装要求\n把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑\nmake  # 编译  \n编译报错的话，make clean可以清空编译\nmake instll  # 编译安装\n4.卸载\n# 不需要卸载命令，直接删除安装目录，不会遗留任何垃圾文件\nrm -rf 安装目录\n```\n脚本安装包并不是独立的软件包类型，常见安装的是源码包\n人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装\n\n- 常见脚本安装包\nWebmin\n是一个基于Web的Linux系统管理界面，可通过图形化的方式设置用户账号、Apache、DNS、文件共享等服务\n```bash\n下载安装包、解压进入目录、执行./setup.sh\nctrl+backspace # 删除乱码\n```\n\n## 用户用户组管理\n#### 用户\n用户配置文件\n##### `… … … /etc/passwd … … … ∞`\n```bash\n# 用户信息文件\n第1字段：用户名称\n第2字段：密码标志，密码占位符\n第3字段：UID（用户ID）0：超级用户1-499：系统用户（伪用户）500-65536：普通用户\n第4字段：GID（用户初始组ID）\n第5字段：用户说明初始组：一登录就有的组，默认和用户同名  附加组：可加入多个附加组，拥有这些组的权限\n第6字段：家目录普通用户：/home/用户名/超级用户：/root/\n第7字段：登录之后的Shell标准Shell是/bin/bash，还可以写如/sbin/nologin（不能登陆）\n```\n##### `… … … /etc/shadow … … … ∞`\n```bash\n# 影子文件\n权限000 仅root可查看\n存放加密后的密码\n第1字段：用户名\n第2字段：加密密码加密算法：SHA512散列加密算法\n如果密码位是\"!!\"or\"*\"代表没有密码，不能登录\n第3字段：密码最后一次修改日期19700101作为标准时间，每过一天时间戳加1\n第4字段：两次密码的修改间隔时间（和第3字段比）\n第5字段：密码有效期（和第3字段比）\n第6字段：密码修改到期前的警告天数（和第5字段比）\n第7字段：密码过期后的宽限天数（和第5字段比）\n0：过期后立即失效\n-1：永不失效\n第8字段：账号失效时间时间戳表示、等级比第5字段高\n第9字段：保留\n\n## 用户管理相关文件\n家目录 # 添加用户时自动生成\n普通用户：/home/用户名/ # 权限700\n超级用户：/root/ # 权限550\n\n## 用户邮箱\n/var/spool/mail/用户名/\n\n## 用户模板目录\n/etc/skel/\n\n## 用户默认值文件\n/etc/default/useradd\nGROUP=100  # 用户默认组\nHOME=/home  # 用户家目录\nINACTIVE=-1  # 密码过期宽限天数（shadow文件第7字段）\nEXPIRE=  # 密码失效时间（shadow文件第8字段）\nSHELL=/bin/bash  # 默认shellSKEL=/etc/skel  # 模板目录\nCREATE_MAIL_SPOOK=yes  # 是否建立邮箱\n```\n##### `… … … /etc/login.defs … … … ∞`\n```bash\nPASS_MAX_DAYS 99999  # 密码有效期（shadow文件第5字段）\nPASS_MIN_DAYS 0  # 密码修改间隔（shadow文件第4字段）\nPASS_MIN_LEN 5  # 密码最小5位（PAM）\nPASS_WARN_AGE 7  # 密码到期警告（shadow文件第6字段）\nUID_MIN 500  # 最小和最大UID范围\nGID_MAX 60000\nENCRYPT_METHOD SHA512  # 加密模式\n```\n命令\n##### `… … … useradd … … … ∞`\n```bash\n# useradd创建的所有新用户会遵循/etc/login.defs下的规定\nuseradd [选项] 用户名\n-u UID：手工指定用户的UID号\n-d 家目录：手工指定用户的家目录\n-c 用户说明：手工指定用户的说明\n-g 组名：手工指定用户的初始组\n-G 组名：指定用户的附加组\n-s shell：手工指定用户的登录shell，默认是/bin/bash\n```\n##### `… … … passwd … … … ∞`\n```bash\n# 超级用户可以更改所有用户的密码，普通用户只能修改自己的密码passwd [选项] 用户名\n-S  # 查询用户密码的密码状态，仅root可用\n-l  # 暂时锁定用户，仅root可用\n-u  # 解锁用户，仅root可用\n--stdin  # 可以通过管道符输出的数据作为用户的密码  \necho \"123\" | passwd --stdin testuser\n除root外，需满足密码复杂度，8位以上，含数字大小写字母\n```\n##### `… … … usermod … … … ∞`\n```bash\n# 修改用户信息\nusermod [选项] 用户名\n-u UID：修改用户的UID号\n-c 用户说明：修改用户的说明信息\n-G 组名：修改用户的附加组\n-L：临时锁定用户\n-U：解锁用户锁定\n-s：修改shell解释器\n```\n##### `… … … chage … … … ∞`\n```bash\n# 修改用户密码状态，用vim shadow也能改\nchage [选项] 用户名\n-l：列出用户的详细密码状态\n-d 日期：修改密码最后一次更改日期（shadow第3字段）\n-m 天数：两次密码修改间隔（shadow第4字段）\n-M 天数：密码有效期（shadow第5字段）\n-W 天数：密码过期前警告天数（shadow第6字段）\n-I 天数：密码过后宽限天数（shadow第7字段）\n-E 日期：账号失效时间（shadow第8字段）\n-E -1：取消刚刚设置的失效时间\n\n账号有效期：是指在一定日期之前，用户账户可以正常使用系统资源的时间范围。在有效期内，用户可以登录系统、使用系统资源与服务等。而一旦过了有效期，系统将会禁止该用户访问系统资源，强制其退出或限制其权限。\n\n常用：chage -d 0 testuser  # 把用户密码修改日期归0，用户一登陆就得修改密码\n```\n##### `… … … userdel … … … ∞`\n```bash\nuserdel [选项] 用户名\n-r：删除用户的同时删除用户家目录\n# 手动删除用户\nvim /etc/passwd\nvim /etc/shadow\nvim /etc/group\nvim /etc/gshadow\nrm -rf /var/spool/mail/lamp\nrm -rf /home/lamp/\n```\n##### `… … … id … … … ∞`\n```bash\n# 查看用户ID\nid 用户名\n```\n##### `… … … su … … … ∞`\n```bash\n# 切换用户身份su\nsu [选项] 用户名\n-：使用-代表连带用户的环境变量一起切换\n-c：仅执行一次命令，而不切换用户身份\n例：不切换成root但执行useradd命令添加testuser用户\nsu -root -c \"useradd testuser\"\nsu - sjwocloud -s /bin/bash\n```\n##### `… … … env … … … ∞`\n```bash\n查看当前用户的环境变量\n```\n#### 用户组\n用户组配置文件\n##### `… … … /etc/group … … … ∞`\n```bash\n# 组信息文件\n第1字段：组名\n第2字段：组密码标志\n第3字段：GID\n第4字段：组中附加用户\n```\n##### `… … … /etc/gshadow … … … ∞`\n```bash\n# 组密码文件\n第1字段：组名\n第2字段：组密码\n第3字段：组管理员用户名\n第4字段：组中附加用户\n```\n##### `… … … groupadd … … … ∞`\n```bash\ngroupadd [选项] 组名\n-g GID：指定组ID\n```\n##### `… … … groupmod … … … ∞`\n```bash\ngroupmod [选项] 组名\n-g GID：修改组ID\n-n 新组名：修改组名\n```\n##### `… … … groupdel … … … ∞`\n```bash\n# 删除用户组\ngroupdel 组名\n```\n##### `… … … gpasswd … … … ∞`\n```bash\n# 修改用户属组，仅限附属\ngpasswd 选项 组名\n-a 用户名：把用户加入组\n-d 用户名：把用户从组中删除\n# 或直接修改组文件/etc/group\n```\n\n\n## 权限管理\n#### 文件类型\n- 文件类型-rw-r--r--\nr 读 4；可以查看文件内容；可以列出目录中的内容\nw 写 2；可以修改文件内容；可以在目录中创建、删除文件\nx 执行 1；可以执行文件；可以进入目录- 普通文件l 软链接\n\n- 文件普通权限\nrw-        r--          r--\nu所有者 g所属组 o其他人（除所有者、所属组以外的用户）\n#### ACL权限\nACL解决身份不足的情况，不考虑ugo的权限\n\n##### `… … … dumpe2fs … … … ∞`\n```bash\n# 查看分区ACL权限是否开启\ndumpe2fs -h /dev/sda3\n# dumpe2fs命令是查询指定分区详细文件系统信息的命令\n-h：仅显示超级块中信息，而不显示磁盘块组的详细信息\n```\n##### `… … … 开启ACL权限 … … … ∞`\n```bash\n## 临时开启分区ACL权限\n# 重新挂载根分区，并挂载加入acl权限\nmount -o remount,acl /\n\n## 永久开启分区ACL权限\n# 加入acl\nvi /etc/fstab\nUUID=c2ca6…… / ext4 defaults,acl  1 1\n# 重新挂载文件系统或重启系统，使修改生效\nmount -o remount /\n```\n##### `… … … 查看ACL权限 … … … ∞`\n```bash\ngetfacl 文件名\n```\n##### `… … … 设定ACL权限 … … … ∞`\n```bash\nsetfacl 选项 文件名\n-m：设定ACL权限\n-x：删除指定的ACL权限\n-b：删除所有的ACL权限\n-d：设定默认ACL权限\n-k：删除默认ACL权限\n-R：递归设定ACL权限\n\n例：给用户testuser赋予r-x权限，使用\"u:用户名:权限\"格式\nsetfacl -m u:testuser:rx /testmulu/\n```\n##### `… … … mask … … … ∞`\n```bash\n# mask是用来指定最大有效权限的，默认情况是rwx\n# 用户拥有ACL权限，需要和mask的权限想与才是真正权限（权限相与：同为r才是r）\n# 修改mask值\nsetfacl -m m:rx /testmulu\n```\n##### `… … … 删除ACL权限 … … … ∞`\n```bash\nsetfacl 选项 文件名\n-x u:用户名 文件名  # 删除指定用户的acl权限\n-x g:组名 文件名  # 删除指定组的acl权限\n-b  # 删除文件的全部acl权限\n```\n##### `… … … 递归ACL权限 … … … ∞`\n```bash\n# 递归是父目录在设定ACL权限时，所有的子文件、子目录也会拥有相同的ACL权限\nsetfacl -m u:用户名:权限 -R 文件名\n```\n##### `… … … 默认ACL权限 … … … ∞`\n```bash\n# 默认ACL权限：给父目录设定了默认ACL权限，当中所有“新建”的子文件都会继承\nsetfacl -m d:u:用户名:权限 文件名\n```\n#### 文件特殊权限\n特殊权限 s\nS代表赋权错误，无任何作用\n##### `… … … SetUID … … … ∞`\n```bash\nSetUID功能：\n只有可执行的二进制程序才能设定SUID权限\n命令执行者要对该程序拥有x权限\n命令执行者在执行该程序时获得该程序文件属主的身份\nSetUID权限只在该程序执行过程中有效\npasswd拥有SetUID权限，所以普通用户可修改密码（/etc/shadow文件默认权限000）\n\n## 设定SetUID命令：\n4<==>SUID\nchmod 4755 文件名\nchmod u+s 文件名\n\n# 取消SetUID权限\nchmod 755 文件名\nchmod u-s 文件名\n\n# 危险的SetUID\n关键目录严格控制写权限，如/、/usr\n```\n##### `… … … SetGID … … … ∞`\n```bash\nSetGID针对文件的作用：\n只有可执行的二进制程序才能设置SGID权限\n命令执行者要对该程序拥有x权限\n命令执行者在执行程序的时候，组身份升级为该程序文件的属组\nSetGID权限同样只在该程序执行过程中有效\n\nSetGID针对目录的作用：\n普通用户必须对此目录拥有rx权限，才能进入此目录\n普通用户在此目录中的有效组会变成此目录的属组\n若普通用户对此目录拥有w权限，新建的文件默认属组时这个目录的 属组\n\n## 设定SetGID命令：\n2<==>SGID\nchmod 2755 文件名\nchmod g+s 文件名\n\n# 取消SetGID权限\nchmod 755 文件名\nchmod g-s 文件名\n```\n##### `… … … Sticky BIT … … … ∞`\n```bash\nSBIT粘着位作用\n粘着位目前只对目录有效\n普通用户对该目录拥有wx权限\n如果没有粘着位，因普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件\n一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算有w，也只能删除自己建立的，无法删除其他用户建立的文件\n\n## 设置粘着位\n1<==>SBID\nchmod 1755 文件名\nchmod o+t 文件名\n\n# 取消粘着位\nchmod 755 文件名\nchmod o-t 文件名\n文件系统属性权限chattr\n```\n##### `… … … chattr … … … ∞`\n```bash\nchattr [+-=][选项] 文件或目录名\n+：增加权限\n-：删除权限\n=：等于某权限\ni：文件：不允许对文件进行改名修改删除      目录：只能修改目录下文件的数据，不允许新增删除文件\na：文件：只能新增数据（追加的方式），不能修改、删除数据       目录：只能新增（追加的方式）、修改文件，不能删除文件\n\n例：# 防止密码泄露 .pass.txt设置权限：不允许修改 不允许删除\nchattr +i .pass.txt\n```\n##### `… … … lsattr … … … ∞`\n```bash\nlsattr 选项 文件名\n-a：显示所有文件和目录\n-d：若目标是目录，仅列出目录本身的属性，为不是子文件的\n```\n#### sudo\n##### `… … … sudo … … … ∞`\n```bash\n## sudo作用\nroot把本来只能超级用户执行的命令赋予普通用户执行\nsudo的操作对象是系统命令\n\n## sudo使用\nvisudo # 实际修改的是/etc/sudoers文件\n# 用户名 被管理主机的地址=(可使用的身份)  授权命令(绝对路径)\n   root     ALL=(ALL)                                     ALL\n# %组名    被管理主机的地址=(可使用的身份)  授权命令(绝对路径)\n   %wheel  ALL=(ALL)                                     ALL\n\n例：授权testuser用户可以重启服务器\nvisudo\ntestuser ALL=/sbin/shutdown -r now\n\n## 普通用户执行sudo赋予的命令\nsu -testuser\nsudo -k  # 查看可用的sudo命令\nsudo /sbin/shutdown -r now  # 执行sudo赋予的命令\n\n# 切换root\nsudo -i\n```\n\n## 文件系统管理\n- 分区规划\nMBR 主分区 4，实际3，最大2T  扩展分区 1  逻辑分区 n\nGPT 主分区 128个，最大18EB\n    - MBR分区类型\n主分区：最多能分4个\n扩展分区：只能有一个，主分区+扩展分区最多有4个；扩展分区不能存储数据和格式化，必须再划分成逻辑分区才能用逻辑分区：IDE硬盘最多支持59个逻辑分区，SCSI硬盘最多支持11个逻辑分区\n1. 分区设备文件名\n主分区1 2 3 /dev/sda1 2 3\n扩展分区 /dev/sda4\n逻辑分区1 2 3 /dev/sda5 6 7  # 逻辑分区固定从sda5开始\n2. 文件系统：空间存储数据的规则\nwindows：NTFS FAT\nlinux：xfs（7以上才有，适合存大文件） ext4\next2：ext的升级版本；1993年发布，支持最大16TB的分区和最大2TB的文件\next3：ext2的升级版本；最大区别是带日志功能以在系统突然停止时提高文件系统的可靠性，支持最大16TB的分区和最大2TB的文件\next4：ext3的升级版；大量改进性能、伸缩性、可靠性；向下兼容ext3、支持最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等；是CentOS6.3的默认文件系统\n\n    - GPT\n两个工具\nfdisk 所有操作保存在内存里，对磁盘不生效，最终保存才会生效，q退出\nparted 敲回车直接更改\n\n##### `… … … mkfs. blkid pv vg lv  … … … ∞`\n```bash\n## 识别硬盘-》分区规划-》格式化-》挂载\n逻辑分区规划：fdisk n +1G w\n\n格式化：赋予空间 文件系统\nmkfs.ext4 /dev/vdc1\nblkid 查看分区文件系统类型\n\n挂载：让目录成为设备的访问点\n\n## 逻辑卷创建流程：创建物理卷(pv)-》创建卷组(vg)-》创建逻辑卷(lv)\n\n# 逻辑卷作用：\n1.整合分散空间\n2.在线动态扩容\n\n\n# 创建卷组\nvgcreate myvg /dev/vdc2 # 会判断分区是否为物理卷，如不是自动pvcreate，可省略pvcreate步骤\nlvcreate -L 1G -n mylv myvg # L指定最终大小，l指定PE个数\n\n扩容卷组\n情况一：卷组有足够空间\n1.扩展逻辑卷：\nlvextend -L 最终大小 逻辑卷的名 \n2.扩展文件系统（blkid查询类型，用对应类型的命令扩展）：\next4：resize2fs\nxfs：xfs_growfs\n\n情况二：卷组没有足够空间\n1.扩展卷组\nvgextend 卷组名  物理卷1  …\n2.扩展逻辑卷：\nlvextend -L 最终大小 逻辑卷的名 \n3.扩展文件系统（blkid查询类型，用对应类型的命令扩展）：\next4：resize2fs\nxfs：xfs_growfs\n\n# 删除逻辑卷（删除倒序删）\numount\nlvremove\nvgremove（需要vg里的lv都删除完）\npvremove /dev/vdc[2-3]\n\n## PE\n# 修改PE大小\nvgchange -s 1M myvg\nvgdisplay myvg # 查看pe大小\n# 创建时指定PE大小\nvgcreate -s 1M myvg /dev/vdc2\n# 创建lv时指定PE个数\nlvcreate -l 50 -n mylv myvg\n```\n##### `… … … swapon … … … ∞`\n```bash\n## 交换空间（虚拟内存）\n# 利用硬盘的空间，充当内存空间\n# 当物理内存占满了，可以将内存中的数据，暂时放入交换空间中，缓解真是物理内存的压力\n\n# 利用硬盘分区制作交换空间\n# 查看交换分区\nswapon -s \n# 格式化为交换分区\nmkswap /dev/vdc3\n# 永久生效，实现开机自动挂载\nvim /etc/fstab\n/dev/vdc3    swap     swap      defaults    0    0\n# 挂载交换分区\nswapon -a\nswapon -s\n# 停用交换分区\nswapoff /dev/vdc3\n```\n##### `… … … NFS … … … ∞`\n```bash\nNetwork  File System网络文件系统\n# 用途\n为客户机提供共享使用的文件夹\n# 所需软件包\nnfs-utils\n# 系统服务\nnfs-server\n# NFS配置\nvim /etc/exports\n目录 网段\n/public 192.25.0.0/24\n\n# 查看服务端共享的目录\nshowmount -e ${ip}\n```\n##### `… … … autofs … … … ∞`\n```bash\nyum install -y autofs\nsystemctl start autofs\nls /misc/cd\ncat /etc/auto.master  # 配置监控点\ncat /etc/auto.misc  # 配置监控点（触发点）子目录，相对路径，相对上一个文件\n```\n\n##### `… … … lsblk … … … ∞`\n```bash\n#查看所有可用块设备信息\n```\n##### `… … … df … … … ∞`\n```bash\ndf [选项] [挂载点]\n-a：显示all文件系统信息，包括特殊文件系统，如/proc、/sysfs\n-h：使用习惯单位显示容量，如KB、MB或GB\n-T：显示文件系统类型\n-m：以MB为单位显示容量\n-k：以KB为单位显示容量（默认KB）\n# 是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）\n# df看到的可用空间是真正的可用空间\n```\n##### `… … … du … … … ∞`\n```bash\n#查看文件、目录大小\ndu [选项] [目录或文件名]\n-a：显示每个子文件的磁盘占用量，默认只统计子目录的磁盘占用量\n-h：使用习惯单位显示磁盘占用率\n-s：统计总占用量，而不列出子目录和子文件的占用量(KB)\n[-H||--si K，M，G以1000为换算单位显示]\n[--exclude=<目录或文件> 略过指定的目录或文件]\n# 是面向文件的，只会计算文件或目录占用的空间\n```\n##### `… … … fsck … … … ∞`\n```bash\n# 文件系统修复命令\nfsck [选项] 分区设备文件名\n-a：不用显示用户提示，自动修复文件系统\n-y：自动修复，和-a作用一致，不过有些文件系统支支持-y\n```\n##### `… … … dumpe2fs … … … ∞`\n```bash\n# 显示磁盘状态\ndumpe2fs 分区设备文件名\n```\n##### `… … … mount … … … ∞`\n```bash\n临时挂载；一个设备能挂载多个挂载点；一个挂载点只能挂载一个设备\n\n# 查询系统中已经挂载的设备，-l会显示卷标名称\nmount [-l]\n\n# 依据配置文件/etc/fstab的内容，自动挂载；检查/etc/fstab文件语法正误\nmount -a\n\nmount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点\n-t 文件系统：加入文件系统类型来指定挂载的类型（ext3、ext4、iso9660等）\n-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载\n-o 特殊选项：可以指定挂载的额外选项\n例：挂载光盘\nmount -t iso9660 /dev/cdrom /mnt/cdrom/\n挂载U盘 # Linux默认不支持NTFS文件系统\nmount -t vfat /dev/sdb1 /mnt/usb/\n\n# 卸载\numount 挂载点\n```\n##### `… … … /etc/fstab … … … ∞`\n```bash\n## 自动挂载（永久挂载）\n/etc/fstab文件（文件写错系统起不来）\n第1字段：分区设备文件名或UUID（硬盘通用唯一识别码）\n第2字段：挂载点\n第3字段：文件系统名称\n第4字段：挂载参数\n第5字段：指定分区是否被dump备份，0 不备份、1 每天备份、2 不定期备份\n第6字段：指定分区是否被fsck检测，0 不检测、其他数字代表优先级\n```\n\n ##### `… … … fdisk … … … ∞`\n```bash\n# 查询新硬盘\nfdisk -l\n\n# 分区\nfdisk /dev/sdb\n所有操作保存在内存里，对磁盘不生效，最终保存才会生效，q退出\n\n# 重新读取分区表信息\npartprobe\n```\n ##### `… … … stat … … … ∞`\n```bash\n#查看文件信息\nstat [文件]\n```\n\n## Shell编程\n#### 基本功能\n- Shell\n是一个命令行解释器，为用户提供一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序\n还是一个功能强大的编程语言，易编写、易调试、灵活性较强，可直接调用Linux系统命令\n\n- Shell分类\nBourne Shell：从1979起Unix就开始使用Bourne Shell，主文件名为sh\nC Shell：C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名\n    - 区别：\nShell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容\nBourne家族主要包括sh、ksh、Bash、psh、zsh\nC家族主要包括：csh、tcsh\n- Bash\nBash与sh兼容，目前使用Bash作为用户的基本Shell\n\n- Linux支持的Shell\n/etc/shells文件可查询\n\n##### `… … … echo -e … … … ∞`\n```bash\necho -e \"\\e[1;31m testcontent \\e[0m\"\n\n## 脚本执行赋予执行权限，直接运行\n  chmod 755 hello.sh\n  ./hello.sh\n通过Bash调用执行脚本\n  Bash hello.sh\n```\n##### `… … … history … … … ∞`\n```bash\nhistory [选项] [历史命令保存文件]\n-c：清空历史命令\n-w：把缓存中的历史命令写入历史命令保存文件~/.bash_history\n# 默认保存1k条，可在环境变量配置文件/etc/profile中进行修改\n## 历史命令调用\n使用上下箭头：调用以前的历史命令\n!n：重复执行第n条历史命令\n!!：重复执行上一条命令\n!字串：重复执行最后一条以该字串开头的命令\n```\n##### `… … … alias … … … ∞`\n```bash\n# 设定命令别名\nalias 别名='原命令'\n\n# 查询命令别名\nalias\n\n# 删除别名\nunalias\n\n永久生效：vi /root/.bashrc\n\n# 命令执行时顺序\n1：用绝对路径/相对路径执行的命令\n2：别名\n3：Bash的内部命令\n4：按照$PATH环境变量定义的目录查找顺序找到的第一个命令\n\n## Bash常用快捷键\nctrl+a：光标移动到行首\nctrl+e：光标移动到行尾\nctrl+c：强制终止当前命令\nctrl+l：清屏，相当于clear\nctrl+u：删除/剪切光标之前的内容\nctrl+k：删除/剪切光标之后的内容\nctrl+w：删除/剪切光标之前的1个词语\nctrl+y：粘贴u、k剪切的内容\nctrl+r：搜索历史命令\nctrl+d：推出当前终端\nctrl+z：暂停并放入后台\nctrl+s：暂停屏幕输出\nctrl+q：恢复屏幕输出\n\n\n## 标准输入输出设备\n设备文件名  文件描述符 类型\n键盘     /dev/stdin    0              标准输入\n显示器  /dev/stdout 1              标准输出\n显示器  /dev/stderr  2              标准错误输出\n\n# 重定向错误输出到文件\n错误命令 2>> 文件\n# 正确输出和错误输出同时覆盖>或追加>>到同一个文件中\n命令 > 文件 2>&1\n命令 &>文件命令 &>/dev/null  ## 相当于将输出丢入到垃圾箱\n# 正确输出追加到文件1，错误输出追加到文件2\n命令>>文件1 2>>文件2\n\n# 输入重定向\n```\n##### `… … … wc … … … ∞`\n```bash\nwc [选项] [文件名]\n-c：统计字节数\n-w：统计单词数\n-l：统计行数\n\n## 多命令顺序执行\n;：多个命令顺序执行\n&&：逻辑与\n||：逻辑或\n# 判断命令是否报错\n命令 && echo yes || echo no\n```\n##### `… … … dd … … … ∞`\n```bash\ndd if=输入文件 of=输出文件 bs=字节数 count=个数\n例：date;dd if=/dev/zero of=/root/testfile bs=1k count=100000; date\n```\n##### `… … … | … … … ∞`\n```bash\n# 管道符，命令1的正确输出作为命令2的操作对象\n命令1 | 命令2\n例：查询正在连接的\nnetstat -an | grep ESTABLISHED\n\n## 通配符\n?：匹配1个任意字符\n*：匹配0或任意多个任意字符（可匹配任何内容）\n[]：匹配中括号中任意一个字符（[abc]代表一定匹配1个字符，或是a、或是b、或是c）\n[-]：匹配中括号中任意1个字符，-代表一个范围（[a-z]代表匹配1个小写字母）\n[^]：逻辑非，标识匹配不是中括号中的1个字符（[^0-9]代表匹配1个不是数字的字符）\n\n## Bash中其他特殊符号\n''：单引号中所有的特殊符号都没有特殊含义（如$ `）\n\"\"：双引号中特殊符号都没有特殊含义（$ ` \\是例外，拥有调用变量的值、引用命令、转义符的特殊含义）\n``：反引号括起来的内容是系统命令，Bash会先执行，和$()作用一样\n$()：引用系统命令\n#：注释\n$：调用变量的值\n\\：转义符，跟在\\之后的特殊字符变为普通字符\n```\n#### 变量、环境变量\n- 变量\n1.定义：计算机内存的单元\n2.规则：\n由字母、数字、下划线组成，不能以数字开头Bash中，变量默认类型是字符串型，要进行数值运算，需修改为数值型\n等号连接，两侧不能有空格\n环境变量建议大写，便于区分\n3.分类\n用户自定义变量（本地变量）\n只在当前的Shell中生效\n\n例：变量叠加\naa=123\naa=${aa}456\naa=\"$aa\"789\n\n环境变量\n主要保存的是和系统操作环境相关的数据会在当前Shell和所有子Shell中生效；如果写入相应配置文件，会在所有的Shell中生效\n\n##### `… … … export … … … ∞`\n```bash\n# 声明变量\nexport 变量名=变量值\n# 查询变量\nenv\n# 删除变量\nunset 变量名\n\n# 系统常见环境变量\nPATH：系统查找命令的路径\nPATH=\"$PATH\":/root/sh  # PATH变量叠加\n\n# 定义系统提示符的变量\nPS1\n\\d：显示日期，格式“星期 月 日”\n\\h：显示简写主机名（默认localhost）\n\\t：显示24小时制时间，格式“HH:MM:SS”\n\\T：显示12小时制时间，格式“HH:MM:SS”\n\\A：显示24小时制时间，格式“HH:MM”\n\\u：显示当前用户名\\w：显示当前所在目录的完整名称\n\\W：显示当前所在目录的最后一个目录\n\\#：执行的第几个命令\n\\$：提示符（root提示#，普通用户提示$）\n例：PS1='[\\u@\\t \\w]\\$ '\n默认PS1='[\\u@\\h \\w]\\$ '\n位置参数变量\n主要是用来向脚本当中传递参数或数据，变量名不能自定义，变量作用固定\n$n：n为数字，$0代表命令本身、$1-$9代表第1-0个参数，10以上的参数需要用大括号如${10}\n$*：代表命令行中所有的参数，把所有参数看成一个整体\n$@：也代表命令行中所有的参数，不过$@把每个参数区分对待\n$#：代表命令行中所有参数的个数\n\n预定义变量\nBash中已定义好的变量，变量名不能自定义，变量作用固定\n$?：最后一次执行的命令的返回状态，值为0 证明正确执行，值为非0（具体哪个数，由命令自己决定）证明执行不正确\n$$：当前进程的进程号（PID）\n$!：后台运行的最后一个进程的PID\n```\n##### `… … … read … … … ∞`\n```bash\nread [选项] [变量名]\n-p \"提示信息\"：等待输入时，输出提示信息\n-t 秒数：指定等待时间\n-n 字符数：只接受指定的字符数\n-s：隐藏输入的数据\n```\n##### `… … … set … … … ∞`\n```bash\n# 查看系统中的变量\nset\n# 删除变量\nunset name\n```\n#### 环境变量配置文件\n##### `… … … source … … … ∞`\n```bash\n# 修改环境配置文件重启或者source生效\nsource 配置文件\n. 配置文件 # .是source的缩写\n\n## 登录时生效的配置文件\n/etc/profile\nUSER变量  \nLOGNAME变量  \nMAIL变量 \nPATH变量  \nHOSTNAME变量  \nHISTSIZE变量  \numask  \n调用/etc/profile.d/*.sh文件\n\n/etc/profile.d/*.sh\n\n~/.bash_profile  \n调用~/.bashrc文件  \n在PATH变量后叠加\":$HOME/bin目录\"\n\n~/.bashrc\n\n/etc/bashrc  \nPS1变量  \numask  \nPATH变量  \n调用/etc/profile.d/*.sh文件\n\n## 注销时生效的环境变量配置文件\n~/.bash_logout\n\n## 其他配置文件\n~/bash_history  \n历史命令存放文件，排错时可查看，文件占用不大，建议不清空\n\n## Shell登录信息\n/etc/issue\n本地终端欢迎信息\n转义符 作用\n/d 当前系统日期\n/s 操作系统名称\n/l 登录的终端号（较常用）\n/m 硬件体系结构（如i386）\n/n 主机名\n/o 域名\n/r 内核版本\n/t 当前系统时间\n/u 当前登录用户的序列号\n\n/etc/issue.net\n远程终端欢迎信息\n转义符在/etc/issue.net文件中不能使用\n是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner /etc/issue.net”行才能显示（需重启SSH服务）\n\n/etc/motd\n本地、远程登录都可显示欢迎信息\n```\n#### 运算符\n数值运算\n##### `… … … declare … … … ∞`\n```bash\n# 声明变量类型，用exporter一样\ndeclare [+/-][选项] 变量名\n-：给变量设定类型属性\n+：取消变量的类型属性\n-i：将变量声明为Integer\n-x：将变量声明为环境变量\n-p：显示指定变量的被声明的类型\n例：计算a+b\n# declare\na=11\nb=22\ndeclare -i c=$a+$b  # 结果为33，而不是1122\n# expr\nd=$(expr $a + $b)  # +左右必须有空格\n# $(()) 或 $[]\nf=$(( $a+$b ))\ng=$[ $a+$b ]\n\n## 运算符\n优先级从高到低 运算符\n13 单目负、单目正 -、+\n12 逻辑非、按位取反或补码 !、~\n11 乘除取余 *、/、%\n10 加减 +、-\n9 左移右移 <<、>>\n8 判断大小 <=、>=、<、>\n7 等于、不等于 ==、!=\n6 按位与 &\n5 按位异或 ^\n4 按位或 |\n3 逻辑与 &&\n2 逻辑或 ||\n1 赋值 =、+=、-=、*=、/=、%=、&amp;=、^=、|=、<<=，>>=\n```\n#### 正则、排序\n- 正则表达式与通配符\n正则是包含匹配（grep、awk、sed等命令支持正则）\n通配符是完全匹配（ls、find、cp等命令不支持正则，只能用shell自带通配符进行匹配）\n\n- 基础正则表达式\n元字符 作用\n```text\n*  前一个字符匹配0或多次\n.  匹配除了换行符外的任意1个字符\n^  匹配行首（例^hello匹配以hello开头的行）\n$  匹配行尾\n[]  匹配中括号中指定的任意1个字符，只匹配1个字符\n[^]  匹配中括号中的字符以外的任意1个字符（[^0-9]匹配任意1位非数字字符）\n\\  转义符，取消特殊符号的含义\n\\{n\\}  表示前面的字符恰好出现n次（[0-9]\\{4\\}匹配4位数字；[1][3-8][0-9]\\{9\\}匹配手机号码）\n\\{n,\\}  表示前面的字符出现不小于n次（[0-9]\\{2,\\}表示两位及以上的数字）\n\\{n,m\\}  表示前面的字符至少出现n次、最多出现m次（[a-z]\\{6,8\\}匹配6-8位的小写字母）\n\n# 例：\ngrep \"a*\" testfile.txt  # 匹配0或多次a，匹配所有内容包括空白行\ngrep \"aa*\" testfile.txt  # 匹配至少有一个a的行\ngrep \"s..d\" testfile.txt  # 匹配sd中间一定有2个字符的单词\ngrep \".*\" testfile.txt  # 匹配所有内容\ngrep -n \"^$\" testfile.txt  # 匹配空白行\ngrep \"\\.$\" testfile.txt  # 匹配使用.结尾的行\n```\n##### `… … … sort … … … ∞`\n```bash\nsort [选项] 文件名\n-f：忽略大小写\n-n：以数值型排序（默认字符串型排序）\n-r：反向排序\n-t：指定分隔符（默认是制表符）\n-k n [,m]：按照指定字段范围排序，n-m（默认到行尾）\n\n# 指定分隔符:，用第3字段开头、第3字段结尾排序\nsort -t \":\" -k 3,3 /etc/passwd\n```\n#### 条件判断\n- 按照文件类型进行判断\n-b：判断文件存在且为块设备文件\n-c：判断文件存在且为字符设备文件\n-d：判断文件存在且为目录 *\n-e：判断文件存在 *\n-f：判断文件存在且为普通文件 *\n-L：判断文件存在且为符号链接文件\n-p：判断文件存在且为管道文件\n-s：判断文件存在且为非空\n-S：判断文件存在且为套接字文件\n\n- 两种判断格式\n```bash\ntest -e testfile\n[ -e testfile ]  # 常用\n例：[ -d /root ] &amp;&amp; echo \"yes\" || echo \"no\"\n```\n- 按照文件权限进行判断\n-r：判断文件存在且有r权限\n-w：判断文件存在且有w权限\n-x：判断文件存在且有x权限\n-u：判断文件存在且有SUID权限\n-g：判断文件存在且有SGID权限\n-k：判断文件存在且有SBit权限\n\n- 两个文件间比较\nfile1 -nt file2：判断file1的修改时间是否比file2的新\nfile1 -ot file2：判断file1的修改时间是否比file2的旧\nfile1 -ef file2：判断file1和file2的Inode号是否一致，可理解为是否为同一个文件，用于判断硬链接是个好方法\n例：\n```bash\n# 创建硬链接后-ef判断\nln file1 file2\n[ file1 -ef file2 ] &amp;&amp; echo \"yes\" || echo \"no\"\n\n## 两个整数间比较\ninteger1 -eq integer2：判断是否相等\ninteger1 -ne integer2：判断是否不相等\ninteger1 -gt integer2：判断integer1是否>integer2\ninteger1 -lt integer2：判断integer1是否<interger2\ninteger1 -ge integer2：判断integer1是否>=integer2\ninteger1 -le integer1：判断integer1是否<=integer2\n\n## 字符串的判断\n-z string：判断字符串是否为空\n-n string：判断字符串是否为非空\nstring1 == string2：判断是否相等\nstring1 != string2：判断是否不相等\n\n## 多重条件判断\n判断1 -a 判断2：逻辑与，都成立结果才为真\n判断1 -o 判断2：逻辑或，有一个成立结果就为真\n! 判断：逻辑非，使原始的判断取反\n```\n#### 流程控制\n##### `… … … if … … … ∞`\n```bash\n## 单分支if条件\nif [ 条件判断式 ]; then\n    程序\nfi\n# 或者\nif [ 条件判断式 ]\n    then\n        程序\nfi\n# 例：判断分区使用率\n#!/bin/bash\n# Author:jade\nrate=$(df -h | grep \"/dev/sda3\" | awk '{print $5}' | cut -d \"%\" -f 1)\nif [ $rate -ge 80 ]\n    then\n        echo \"warning! /dev/sda3 is full!!\"\nfi\n\n## 多分支if条件\nif [ 条件判断式1 ]\n    then\n        程序\nelif [ 条件判断式2 ]\n    then\n        程序\n……\nelse\n    程序\nfi\n\n# 检查服务是否启动\nnmap\n# 结果是open证明服务启动\nnmap -sT ip | grep tcp | grep http |awk '{print $2}'\n```\n##### `… … … case … … … ∞`\n```bash\ncase $变量名 in\n    \"value1\")\n        程序\n        ;;\n    \"value2\")\n        程序\n        ;;\n    ……\n    *)\n        程序\n        ;;\nesac\n```\n##### `… … … for … … … ∞`\n```bash\n# 语法1\nfor 变量 in 值1 值2 值3……\n    do\n        程序\n    done\n# 例：批量解压缩脚本\nls *.tar.gz > jieya.log\nfor i in $(cat jieya.log)\n    do\n        tar -zxf $i &amp;>/dev/null\n    done\nrm -rf jieya.log\n\n# 语法2\nfor (( 初始值;循环控制条件;变量变化 ))\n    do\n        程序\n    done\n```\n##### `… … … while … … … ∞`\n```bash\n# 条件成立进入循环\nwhile [ 条件判断式 ]\n    do\n        程序\n    done\n```\n##### `… … … until … … … ∞`\n```bash\n# 条件不成立进入循环\nuntil [ 条件判断式 ]\n    do\n        程序\n    done\n例：重复提示输入yes no\nread DEPLOYMENT_YN\nuntil [[ ${DEPLOYMENT_YN} =~ ^([Nn][Oo]|[Nn]|[yY]|[yY][eE][sS])$ ]]; do\n  echo -e \"\\033[41;30;5m … … 输入错误，请重新输入 \\033[0m\"\n  read DEPLOYMENT_YN\ndone\n```\n\n## 服务管理\n#### RPM包服务源码包服务\nLinux服务包括：RPM包默认安装的服务、源码包安装的服务\nRPM包默认安装的服务包括：独立的服务、基于xinetd服务\n独立的服务：在内存中启动，响应更快\n基于xinetd服务：不占用内存，但响应较慢\n\n- 启动与自启动\n服务启动：在当前系统中让服务运行并提供功能\n服务自启动：开机或重启后，随着系统的启动而自动启动服务\n\n- 查询已安装的服务\nRPM包安装的服务\n```bash\n# 查看自启动的服务，可以看到所有RPM包安装的服务，2 3 4 5如果是启用代表启用\n  \tchkconfig --list  \n```\n- 查看当前启动的服务  \n```bash\nps aux | grep  \nnetstat -tlun\n```\n源码包安装的服务  \n查看服务安装位置，一般是/usr/local/下\n\n- RPM包安装服务与源码包安装服务的区别\nRPM包安装在默认位置\n源码包安装在指定位置，一般是/usr/local/\n\n- RPM包服务安装默认位置\n/etc/init.d/：启动脚本位置\n/etc/sysconfig/：初始化环境配置文件位置\n/etc/：配置文件位置\n/etc/xinetd.conf：xinetd配置文件\n/etc/xinetd.d/：基于xinetd服务的启动脚本\n/var/lib/：服务产生的数据放在这里\n/var/log/：日志\n\n- 独立服务的启动  \n/etc/init.d/独立服务名 start|stop|status|restart  \nservice 独立服务名 start|stop|status|restart *\n- 独立服务的自启动  \nchkconfig [--level 运行级别] [独立服务名] [on|off]  \n修改/etc/rc.d/rc.local文件 *  \n使用ntsysv命令管理自启动\n- 源码包服务的启动\n使用绝对路径调用启动脚本；不同的源码包的启动脚本不同，可查看对应方法\n例：/usr/local/apache2/bin/apachectl start|stop\n- 源码包服务的自启动\n修改/etc/rc.d/rc.local加入/usr/local/apache2/bin/apachectl start\n- 让源码包服务被service命令识别，做软链接，建议不这么做\nln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache\n\n## 系统管理\n- 查看linux系统版本\n```bash\ncat /etc/redhat-release\n```\n\n- 进程\n正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源\n- 作用判断服务器健康状态查看系统中所有进程杀死进程\n- 进程查看\n##### `… … … ps … … … ∞`\n```bash\n# 查看系统中所有进程，使用BSD操作系统格式\nps aux\n# 查看系统中所有进程，使用Linux标准命令格式\nps -le\n# 列含义  \nUSER：该进程是由哪个用户产生的  \nPID：进程的ID号 \n%CPU：该进程占用CPU资源的百分比；占用越高，进程越耗费资源  \n%MEM：该进程占用物理内存的百分比；占用越高，进程越耗费资源  \nVSZ：该进程占用虚拟内存的大小（单位KB）  \nRSS：该进程占用实际物理内存的大小（单位KB） \nTTY：该进程是在哪个终端中运行（tty1-tty7代表本地控制台终端；tty1-tty6代表本地字符界面终端；tty7代表图形终端；pts/0-256代表虚拟终端）  \nSTAT：进程状态（常见：R运行 S睡眠 T停止 s包含子进程 +位于后台）  \nSTART：该进程的启动时间  \nTIME：该进程占用CPU的运行时间（不是系统时间） \nCOMMAND：产生此进程的命令名\n```\n##### `… … … top … … … ∞`\n```bash\n# 查看系统健康状态\ntop [选项]\n-d 秒数：指定top命令每隔几秒更新（默认3s）\n# 交互模式中可执行的命令  \n?或h：显示交互模式的帮助  \nP：以CPU使用率排序（默认） \nM：以Memory使用率排序  \nN：以PID排序  \nq：退出top\n# top展示内容解析\n1.第一行信息为任务队列信息  \n12:26:46：系统当前时间  \nup 1 day,13:32：系统的运行时间（断电会重置）  \n2 users：当前登录了2个用户 \nload average:0.00,0.00,0.00：系统在之前1min、5min、15min的平均负载（一般<1时负载较小，>1时系统已经超过负荷）\n2.第二行为进程信息  \nTasks:95 total：系统中的进程总数  \n1 running：正在运行的进程数  \n94 sleeping：睡眠的进程  \n0 stopped：正在停止的进程  \n0 zombie：僵尸进程（如不为0，需手工检查僵尸进程）\n3.第三行为CPU信息  \nCpu(s):0.1%us：用户模式占用的CPU百分比  \n0.1%sy：系统模式占用的CPU百分比  \n0.0%ni：改变过优先级的用户进程占用的CPU百分比  \n99.7%id：空闲CPU的CPU百分比 * \n0.1%wa：等待输入/输出的进程的占用CPU百分比  \n0.0%hi：硬中断请求服务占用的CPU百分比  \n0.1%si：软中断请求服务占用的CPU百分比  \n0.0%st：st（Steal time）虚拟时间百分比（当有虚拟机时，虚拟CPU等待实际CPU的时间百分比）\n4.第四行物理内存信息 \nMem:625344k total：物理内存的总量（单位KB）  \n571504l used：已经使用的物理内存数量  \n53840k free：空闲的物理内存数量  \n65800k buffers：作为缓冲的内存数量\n5.第五行交换分区（swap）信息  \nSwap:524280k total：交换分区（虚拟内存）的总大小；最大不超过2G，否则就是浪费空间  \n0k used：已经使用的交互分区的大小  \n524280k free：空闲交换分区的大小  \n409280k cached：作为缓存的交互分区的大小\niotop\n```\n##### `… … … pstree … … … ∞`\n```bash\n# 查看进程树\npstree [选项]\n-p：显示进程的PID\n-u：显示进程的所属用户\n```\n- 进程管理\n##### `… … … kill … … … ∞`\n```bash\nkill -l  # 查看可用的进程信号\nkill -1 PID  # 重启进程\nkill -9 PID  # 强制杀死进程\n# 常用信号代号 名称  \n1 SIGHUP 该信号让进程立即关闭，然后重新读取配置文件后重启 *  \n2 SIGINT 程序终止信号，用于终止前台进程（相当于ctrl+c）  \n8 SIGFPE 发生致命的算术运算错误时发出（不仅包括浮点运算错误，还包括溢出及除数为0等其他所有的算数错误）  \n9 SIGKILL 立即结束程序的运行，一般用于强制终止进程（此信号不能被阻塞、处理和忽略）*  \n14 SIGALRM 时钟定时信号，alarm函数使用该信号（计算的是实际时间或时钟时间）  \n15 SIGTERM 正常结束进程的信号，kill的默认信号（有时此信号无法正常终止进程，才尝试使用9 SIGKILL信号）*  \n18 SIGCONT 让暂停的进程恢复执行（此信号不能被阻断）  \n19 SIGSTOP 暂停前台进程（相当于ctrl+z）（此信号不能被阻断）\n```\n##### `… … … killall … … … ∞`\n```bash\n# 按照进程名杀死进程\nkillall [选项][信号] 进程号\n-i：交互式，询问是否要杀死某个进程\n-I：忽略进程名的大小写\n```\n##### `… … … pkill … … … ∞`\n```bash\n# 按照进程名终止进程\n-t 终端号：按照终端号踢出用户\n例：\nw # 查询本机已经登录的用户\npkill -t -9 pts/1 # 强制杀死从pts/1虚拟终端登录的进程\n\n## 工作管理\n# 把进程放入后台\n1.用&amp;放入后台\ntar -zcf testfile.tar.gz /tmp &amp;\n2.ctrl+z\ntop执行中按下ctrl+z\n```\n##### `… … … jobs … … … ∞`\n```bash\n# 查看后台的工作\njobs [-l]\n-l：显示工作的PID\n（+代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作）\n（-代表代数第二个放入后台的工作）\n（其他没有符号标记）\n```\n##### `… … … fg … … … ∞`\n```bash\n# 将后台暂停的工作恢复到前台执行\nfg %工作号%工作号：%号可省略，工作号和PID不是一个，工作号是jobs显示的号\n```\n##### `… … … bg … … … ∞`\n```bash\nbg %工作号\n# 和前台有交互的命令，不能恢复到后台执行，例top、vi\n```\n- 系统资源查看\n##### `… … … vmstat … … … ∞`\n```bash\n# 监控系统资源\nvmstat [刷新延时 刷新次数]\nvmstat 1 3  # 监听3次系统资源，每隔2s\n```\n##### `… … … dmesg … … … ∞`\n```bash\n# 开机时内核检查\ndmesg\ndmesg | grep CPU\n\n# 查看内核日志是否打raid卡堆栈信息\ndmesg -T |grep megasas_probe_one -C5\n```\n##### `… … … free … … … ∞`\n```bash\n# 查看内存使用状态、空闲情况，默认树形Mem物理内存swap交互区内存 内核缓存区内存\nfree [-b|-k|-m|-g]\n-b：以字节为单位显示\n-k：以KB为单位显示（默认）\n-m：以MB为单位显示\n-g：以GB为单位显示\n[-s<间隔秒数> 持续观察内存使用状况]\n[-t 显示内存总和列]\n[-l 以列表形式]\n\n# 缓存和缓冲的区别\n缓存（cache）：用来加速数据从硬盘中读取\n缓冲（buffer）：用来加速数据写入硬盘\n\n# 查看CPU信息\ncat /proc/cpuinfo\ncat /proc/cpuinfo | grep processor\nnproc\nlscpu\n```\n##### `… … … uptime … … … ∞`\n```bash\nuptime  # 显示系统的启动时间和平均负载（相当于top第一行），w也可以看到\n```\n##### `… … … uname … … … ∞`\n```bash\n# 查看系统与内核相关信息\nuname [选项]\n-a：查看系统所有相关信息\n-r：查看内核版本\n-s：查看内核名称\n\nfile /bin/ls  # 判断当前系统的位数\nlsb_release -a  # 查看当前Linux系统的发行版本\n```\n##### `… … … lsof … … … ∞`\n```bash# \n列出进程调用或打开的文件的信息\nlsof [选项]\n-c 字符串：只列出以字符串开头的进程打开的文件\n-u 用户名：只列出某个用户的进程打开的文件\n-p pid：列出某个PID进程打开的文件\nlsof -c init\n\n## 系统定时任务\ncrond服务管理与访问控制\nservice crond restart\nchkconfig crond on\n```\n##### `… … … crontab … … … ∞`\n```bash\ncrontab [选项]\n-e：编辑crontab定时任务\n-l：查询crontab任务\n-r：删除当前用户所有的crontab任务\n-u: 指定用户，不写默认是当前用户\n\ncrontab -e界面（最小识别的范围是分钟）\n* * * * * 执行的任务（绝对路径）\n第1个*：一小时中的第几分钟 [0,59]\n第2个*：一天中的第几小时 [0,23]\n第3个*：一个月中的第几天 [1,31]\n第4个*：一年中的第几月 [1,12]\n第5个*：一周中的星期几 [0,7]（0、7都代表周日）\n\n特殊符号：\n*：任何时间\n,：不连续的时间\n-：连续的时间范围\n*/n：频率，每隔多久执行一次\n例：\n0 5 1,15 * * 命令  每月1号,15号的凌晨5点0分执行命令\n40 4 * * 1-5 命令  每周一到周五的凌晨4点40执行命令\n*/10 4 * * * 命令  每天凌晨4点，每隔10分钟执行一次命令\n10-20/2 * * * * /usr/bin/date >> /opt/time  每小时的10分-20分内每隔2分执行一次\n# 注意\n定时任务调用的脚本内，%号要转义，否则不识别\n```\n##### `… … … lspci … … … ∞`\n```bash\nlspci |grep -i sas 查看raid卡型号\n查看raid卡固件版本和驱动版本\necho \"LSI\" && /opt/MegaRAID/storcli/storcli64 /c0 show |grep -E 'FW Version|Driver Version'\necho \"PMC\" && /usr/sbin/arcconf getconfig 1 ad |grep -wE 'Firmware|Driver *:'\n```\n##### `… … … systemctl … … … ∞`\n```bash\n#列出启动失败的服务\nsystemctl list-units --state failed\nsystemctl status [unit]\n# 设置开机自启，并且立即启动\nsystemctl enable crond --now\n```\n##### `… … … md5 … … … ∞`\n```bash\nmd5sum\n```\n\n\n## 日志管理\n- 日志服务\ncentos6.x中日志服务由rsyslogd取代原本的syslogd\nrsyslogd更先进、功能更多，和syslogd相兼容\n\n- rsyslogd的新特点  \n基于TCP网络协议传输日志信息  \n更安全的网络传输方式  \n有日志消息的及时分析框架  \n后台数据库  配置文件中可以写简单的逻辑判断  \n与syslog配置文件相兼容\n\n- 查看rsyslogd服务是否启动\n```bash\nps aux | grep rsyslogd\n```\n- 查看是否自启动\n```bash\nchkconfig --list | grep rsyslog\n```\n\n- 常见日志的作用\n/var/log/cron：系统定时任务相关日志\n/var/log/cups/：打印信息日志\n/var/log/dmesg：系统在开机时内核自检的信息，也可使用dmesg直接查看内核自检信息\n/var/log/btmp：错误登录的日志（二进制文件，不能用vi查看，需要使用lastb命令查看）\n/var/log/lastlog：系统中所有用户最后一次的登录时间的日志（二进制文件，使用lastlog查看）\n/var/log/mailog：邮件信息\n/var/log/message：系统重要信息的日志（记录linux系统绝大多数重要信息，如出现问题，首先检查该文件）\n/var/log/secure：验证和授权方面的信息，只要涉及账户和密码的程序都会记录（比如系统的登录、ssh的登录、su切换用户、sudo授权、useradd、修改用户密码都会记录在此）\n/var/log/wtmp：永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机时间（二进制文件，用last查看）\n/var/run/utmp：当前已登录的用户信息，会随着用户的登录、注销而不断变化，只记录当前登录用户信息（二进制文件，用w、who、users等命令查看）\n除系统默认的日志外，rpm安装的系统服务也会默认把日志记录在/var/log/中（源码包安装的服务日志在源码包指定目录中），不由rsyslogd服务来记录和管理，由各个服务使用自己的日志管理文档来记录自身日志\n\n- rpm包安装服务的日志\n/var/log/httpd/：rpm包安装的apache服务的默认日志目录\n/var/log/mail/：rpm包安装的邮件服务的额外日志目录\n/var/log/samba/：rpm包安装的samba服务的日志目录\n/var/log/sssd/：守护进程安全服务目录\n\n- rsyslogd服务日志文件格式\n时间产生的时间、发生事件的服务器的主机名、产生时间的服务名或程序名、事件的具体信息\n\n- /etc/rsyslog.conf配置文件\n```text\n# 服务名称[连接符号]日志等级  日志记录位置\nauthpriv.*  /var/log/securre  # 认证相关服务.所有日志等级  记录在/var/log/secure日志中\n1.服务名称\nauth：安全和认证相关消息（不推荐使用authpriv替代）\nauthpriv：安全和认证相关消息（私有的）\ncron：系统定时任务cront和at产生的日志\ndemon：和各个守护进程相关的日志\nftp：ftp守护进程产生的日志\nkern：内核产生的日志（不是用户进程产生的）\nlocal0-local7：为本地使用预留的服务\nlpr：打印产生的日志\nmail：邮件收发信息\nnews：与新闻服务器相关的日志\nsyslog：syslogd服务产生的日志信息（虽然服务名已改为rsyslogd，但很多配置都还沿用syslogd）\nuser：用户等级类别的日志信息\nuucp：uucp子系统的日志信息，uucp是早期linux系统进行数据传递的协议，后来也常用在新闻组服务中\n2.连接符号\n*：代表所有日志等级\n.：代表只要比后面的等级高的日志都记录下来（cron.info代表cron服务产生的日志，只要日志登记≥info级别就记录）\n.=：代表只记录所需等级日志，其他等级都不记录（*.=emerg代表人和日志服务产生的日志，只要等级是emerg等级就记录，这种用法极少见）\n.!：代表不等于，除了该等级的日志外都记录\n3.日志等级\ndebug：一般的调试信息说明\ninfo：基本的通知信息\nnotice：普通信息，但有一定的重要性\nwarning：警告信息，但还不会影响到服务或系统的运行\nerr：错误信息，一般达到err等级的信息已经可以影响到服务或系统的运行了\ncrit：临界状态信息，比err等级还要严重\nalert：警告状态信息，比crit还要严重，必须立即采取行动\nemerg：疼痛等级信息，系统已无法使用\n4.日志记录位置\n日志文件的绝对路径，如/var/log/secure\n系统设备文件，如/dev/lp0\n转发给远程主机，如@192.168.0.210.514\n用户名，如root\n忽略或丢弃日志，如~\n```\n- 日志轮替\n```text\n# 日志文件的命名规则\n1.如果配置文件中有用dateext参数，日志会用日期作为后缀，例secure-20221219，这样文件名不会重叠\n2.如果配置文件中没有dateext参数，日志文件需要进行改名。第一次进行日志轮替时，当前secure自动改名为secure.1，新建secure日志用来保存新的日志，第二次轮替，secure.1自动改名为secure.2以此类推\n# logrotate配置文件\ndaily：日志轮替周期为每天\nweekly：日志轮替周期为每周\nmonthly：日志轮替周期为每月\nrotate 数字：保留的日志文件的个数，0指没有备份\ncompress：日志轮替时，旧的日志进行压缩\ncreate mode owner group：建立新日志，同时指定新日志的权限与所有者和所属组（如create 0600 root utmp）\nmail address：日志轮替时，输出内容通过邮件发送到指定邮件地址\nmissingok：如果日志不存在，则忽略该日志的警告信息\nnotifempty：如果日志为空文件，则不进行日志轮替\nminsize 大小：日志轮替的最小值，日志一定要达到最小值才会轮替，否则就算时间达到也不轮替\nsize 大小：日志只有大于指定大小才进行日志轮替，而不是按照时间轮替（如size 100k）\ndateext：使用日期作为日志轮替文件的后缀\n# 把apache日志加入轮替\nvi /etc/logrotate.conf\n/usr/local/apache2/logs/access_log {\n    daily\n    create\n    rotate 30\n}\n```\n##### `… … … logrotate … … … ∞`\n```bash\nlogrotate [选项] 配置文件名\n空选项：按照配置文件中的条件进行日志轮替\n-v：显示日志轮替过程\n-f：强制进行日志轮替（不管日志轮替的条件是否已符合，强制配置文件中所有的日志进行轮替）\n```\n\n## 启动管理\n- CentOS6.x启动管理\n```text\n# 系统运行级别\n0：关机\n1：单用户模式（相当于windows的安全模式，主要用于系统修复）\n2：不完全的命令行模式，不含NFS服务\n3：完全的命令行模式，就是标准字符界面\n4：系统保留\n5：图形模式\n6：重启动\n```\n##### `… … … runlevel … … … ∞`\n```bash\n查看运行级别\n```\n##### `… … … init … … … ∞`\n```bash\n# 改变运行级别\ninit 运行级别\n\n# 系统默认运行级别\nvim /etc/inittab\n# 系统开机后直接进入指定运行级别\nid:3:initdefault:\n\n# 系统启动过程\n```\n\n\n## 备份恢复\n- linux系统需要备份的数据\n/root/目录、/home/目录、/var/spool/mail/目录、/etc/目录、其他目录\n\n- 备份策略\n完全备份：把左右需要备份的数据全部备份，可备份整块硬盘、整个分区或某个具体的目录\n增量备份：\n差异备份：\n##### `… … … dump … … … ∞`\n```bash\ndump [选项] 备份后的文件名 原文件或目录\n-level：0-9十个备份级别\n-f 文件名：指定备份后的文件名\n-u：备份成功后，把备份时间记录在/etc/dumpdates文件\n-v：显示备份过程中更多的输出信息\n-j：调用bzlib库压缩备份文件，其实就是把备份文件压缩成.bz2格式\n-W：显示允许被dump的分区的备份等级及备份时间\n```\n## 其他\n##### `… … … chrony … … … ∞`\n```bash\nchronyc sources -v\n^* 代表正确\n^? 异常，需检查配置文件\n```\n##### `… … … tcpdump … … … ∞`\n```bash\ntcpdump -i eth0 vrrp -n\n[ecm00]# tcpdump -nnei tapd12345-67 icmp and host ${ip}\n\ntcpdump -nnei bond_virt icmp and host ${ip1} and host ${ip2}\nVLAN861，虚机1（宿主机1）丢包，抓包现象是包到了目标节点，目标节点的回包从目标节点出去后，没回到源节点\n网络上没有查出有异常情况，上述三个mac均在一个接入交换机上，端口，光功率，链路，lldp的端口连线，lacp均正常，收发包正常，mac学习正常，无飘逸，无环路\n```\n##### `… … … openssl … … … ∞`\n```bash\n#生成随机密码\nopenssl rand -base64 14 | cut -b 1-14\n```\n##### `… … … 登录信息 … … … ∞`\n```bash\n登录机器分别排查一下登录记录等信息\ntail -n 100 /var/log/secure | /bin/grep Accepted\ntail -n 50 /root/.bash_history\ntail -n 10 /etc/shadow\n/sbin/ss -antp\ndmesg|tail -n 50\ncat /etc/login.defs|/bin/grep -v ^#\ncrontab -l\ncat /etc/haproxy/haproxy.cfg | /bin/grep -v ^#\n```\n##### `… … … git … … … ∞`\n```bash\n## 提交代码\ngit add. // 添加分支代码到暂存区域\ngit commit -m \"fixed:----\" // 提交分支代码\ngit commit --amend -m \"修改一下\" // 修改最近一次commit\ngit reset --soft HEAD^ // 撤销最近一次commit\ngit reset --soft HEAD~n // 撤销最近n次commit\ngit revert HEAD // 撤销更改并推到远端\n## 分支\ngit branch // 查看当前分支\ngit branch -a // 查看远程分支\ngit branch ${分支名} // 创建分支,仅保存本地\ngit push 远程仓库名 ${远程分支名} // 推到远端\ngit checkout ${分支名} // 切换本地分支\ngit switch ${分支名} // 切换本地分支\ngit checkout -b ${分支名} // 创建新分支并切换到新分支\ngit merge bugFix // 合并bugFix分支到当前分支（合并后还是两个分支，只不过merge后在这个点交汇，建议用merge）\ngit rebase bugFix // 合并bugFix分支到当前分支（合并前commit会消失，合并为一个分支）\n# 查看当前分支\ngit status\n# 查看当前分支提交历史\ngit log\n```\n\n\n\n##### `… … … dmidecode … … … ∞`\n```bash\n# 查看是虚机还是物理机\ndmidecode -t system\nsystemd-detect-virt  结果none是物理机\n```\n##### `… … … sar … … … ∞`\n```bash\n# 查看时间段负载记录\nsar -q -s 15:00:00 -e 16:00:00\n```\n##### `… … … storcli64 … … … ∞`\n```bash\n存储节点存在过周六11点左右业务卡顿的问题，将raid卡的CC和PR功能关闭，问题解决。\nCC&PR一般是在每周六的11点开始启动，会占用磁盘IO，特殊情况下CC会长时间无法完成\n \n近期容器管理节点出现卡顿问题，经排查是CC和PR导致，现建议关闭已受影响的节点。\n \n故障现象：\n1，机器卡顿\n2，磁盘使用率高\n3，CPU使用率高\n4，此故障常出现于周六11时左右\n \n如无其他硬件及业务问题请关闭CC&PR\nLSI raid卡（Broadcom博科旗下）关闭方法：\n# 停止当前任务\n/opt/MegaRAID/storcli/storcli64 /c0 stop patrolread\n# 彻底关闭pr\n/opt/MegaRAID/storcli/storcli64 /c0 set patrolread=off\n\n # 停止当前任务\n/opt/MegaRAID/storcli/storcli64 /c0/vall stop cc\n# 彻底关闭cc\n/opt/MegaRAID/storcli/storcli64 /c0 set cc=off\n \nAdaptec（Microchip微芯旗下）卡关闭方法：\n# PM卡只有一个cc参数，两者同时关闭开启\narcconf CONSISTENCYCHECK 1 off\n```\n##### `… … … hostname … … … ∞`\n```bash\nhostname -f 查看fqdn 主机名+域名 完全域名\n```\n##### `… … … ansible … … … ∞`\n- 【背景】\nansible首次发布于2012年，作者Michael DeHaan\nMichael DeHaan也是Cobbler的作者\n于2015年被RedHat收购\nAnsible是一款自动化运维工具，基于Python开发（控制端需要有python环境）\n批量系统部署、程序部署、运行命令等功能\n- 【特色】\n1.基于ssh做远程管理，被控制端必须开启ssh服务\n2.模块丰富\n3.社区活跃\n4.支持自定义模块\n5.支持异构IT架构\n6.部署简单，容易上手\n\n- 【下载】\ndnf -y install ansible-core ansible-navigator\nansible-core 主程序包\nansible-navigator 9版本，可以调用容器中模块的包\n- 【配置】\n主配置文件：/etc/ansible/ansible.cfg\nAnsible配置文件查找顺序：\n首先检测ANSIBLE_CONFIG变量定义的配置文件\n其次检查当前目录下的ansible.cfg文件\n再次检查当前用户家目录下的.ansible.cfg文件\n最后检查/etc/ansible/ansible.cfg文件\n/etc/ansible/ansible.cfg里可参考，执行ansible-config init --disabled > /tmp/ansible.cfg可看到真实配置\n```bash\n## 写配置\nmkdir ansible;cd ansible;vim ansible.cfg\n# 加空格只是为了美观\n[defaults]\ninventory = ./jadehosts  # ˈɪnvəntɔːri  (建筑物里的物品、家具等的)清单；指定主机清单\nremote_user = jade # 指定用户，不写默认root\n\n[privilege_escalation] # 权限相关配置\nbecome=True # 是否需要切换用户\nbecome_method=sudo # 以什么样的形式切换\nbecome_user=root # 切换成什么用户\nbecome_ask_pass=False # 切换时是否需要输入密码\n\n\nvim ./jadehosts // 配置主机ip或域名\n[test]\nnode1\n[webserver]\nnode[3:4]\n[test2]\nnode2\n[qiantaozu:children]\ntest\nwebserver\n```\n```bash\n# 检查配置是否正确，查看所有主机列表\nansible all --list-hosts\nansible node1,qiantaozu -m ping\n# ansible执行结果颜色区分：红色（报错）；绿色（成功）；黄色（执行发生改变了）\n## 配置机器免密\n#生成秘钥、传公钥给受管主机\nssh-keygen -f /root/.ssh/id_rsa -N ' '\nls /root/.ssh/\n#传输命令之一ssh-copy-id 主机\nfor i in node{1..5} ;do ssh-copy-id $i;done\n#检查是否免密\nansible node1 -m ping\n# 虽说模块名是ping，但不走icmp协议的策略，和平时的ping不一样，这里的ping只检测能否ssh、有无python环境，都ok返回success\n```\n- 【ansible ad-hoc命令行】\nansible ad-hoc是一种通过命令行批量管理的方式，适合执行一些临时性简单任务\n语法格式：ansible 主机集合 -m 模块名 -a \"参数\" （不指定-m，默认command）\n默认模块为【command】：把linux操作系统中所有可执行的命令，传递给被管理主机，直接执行命令\nansible node1 -m command -a \"uptime\"\n\n- 查看模块帮助\nansible-doc command\nansible-doc -l | wc -l # 统计有多少个模块\n\n- 【常用模块】\n    - shell模块\n与command模块区别：\n\tcommand模块不支持bash特性，如管道和重定向等功能\n\t所有需要调用shell的功能都无法使用\n\tshell模块会启动shell执行命令，不可以使用shell模块执行交互命令，如vim、top等\n```bash\nansible node1 -m command -a 'ps &' # ps放到后台，报错\nansible node1 -m command -a 'ps > a.txt' # 报错\nansible node1 -m command -a 'ps aux | wc -l' # 报错\nansible node1 -m shell -a 'ps aux | wc -l' # 成功\n```\n\n    - script模块\nscript允许在本地写脚本，拷贝到被管理端并执行脚本\n可以是shell、python、perl脚本，可以没有-x\n```bash\nvim test.sh\n#!/bin/bash\ntouch /opt/a.txt\nuseradd bob\n\nansible node1,node2 -m script -a \"./teset.sh\"\nansible node1,node2 -m shell -a \"ls /opt;id bob\"\n```\n    - file模块\n可以创建文件、目录、链接；修改权限与属性等\n幂等性：任意次执行所产生的影响均与一次执行的影响相同\n```bash\n# 新建文件\nansible node1 -m file -a \"path=/tmp/file.txt state=touch\"\n# 新建目录\nansible node1 -m file -a \"path=/tmp/mydir state=directory\"\n# 修改文件权限（修改时，所有者、所属组必须存在）\nansible node1 -m file -a \"path=/tmp/file.txt owner=sshd group=adm mode=0777\"\n# 删除文件目录\nansible node1 -m file -a \"path=/tmp/mydir state=absent\"\n# 创建链接文件(类似快捷方式)\nansible node1 -m file -a \"src=/etc/hosts path=/tmp/hosts state=link\"\nansible node1 -m shell -a \"ls -l /tmp/hosts\"\n```\n    - copy模块\n将文件拷贝到远程主机\nbackup=yes如果目标主机有同名文件，先备份\n幂等性\n```bash\n# 新建测试文件\necho \"test\" > ~/a.txt\n# 拷贝到目标主机指定目录下\nansible testnodezu -m copy -a \"src=~/a.txt dest=/root\"\n# 拷贝到目标主机指定目录下并重命名\nansible testnodezu -m copy -a \"src=~/a.txt dest=/root/achage.txt\"\n# 没有源文件，通过content直接提供文件内容 \\n代表回车\nansible testnodezu -m copy -a \"content='hello world\\ntest' dest=/root/test.txt\"\n```\n    - fetch模块\n与copy作用相反，将其他主机的文件拷贝到本地\n```bash\n# 将远程主机的hostname文件下载到本地家目录（避免多个主机同名文件，fetch会在拷贝时新增对应主机名的目录）\nansible node1 -m fetch -a \"src=/etc/hostname dest=~/\"\nls ~/node1/etc\n```\n    - lineinfile|replace模块\n幂等性\n```bash\n## 在修改单个文件的单行内容时可以使用lineinfile模块\n# 在/etc/issue中添加一行，默认加到最后一行；基于幂等性，重复执行只会有一行\nansible node1 -m lineinfile -a \"path=/etc/issue line='hello world'\"\n## lineinfile会替换一整行，replace可以替换关键词\n# 将/etc/issue.net文件全文所有的Kernel替换为Ocean\nansible node1 -m replace -a \"path=/etc/issue.net regexp=Kernel replace=Ocean\"\n```\n    - user模块\n```bash\n# 远程test组中所有主机，并创建系统用户tuser1，state不写默认是present（创建）\nansible test -m user -a \"name=tuser1\"\n# 创建用户并设置对应的用户属(groups指定附加组，home指定家目录，shell指定解释器)\nansible node1 -m user -a \"name=tuser2 uid=1020 group=adm groups=daemon,root home= shell=\"\n# 修改用户密码(ansible修改的密码需经过password_hash('sha512')加密，否则不生效)\nansible node1 -m user -a \"name=tuser1 password={{'abc' | password_hash('sha512')}}\"\nssh tuser1@node1\n# 修改tuser1用户的附加组\nansible node1 -m user -a \"name=tuser1 groups=daemon\"\n# 删除用户tuser1\nansible node1 -m user -a \"name=tuser1 state=absent\"\n# 删除用户tuser2（删除时同步删除家目录、邮箱）\nansible node1 -m user -a \"name=tuser1 state=absent remove=true\"\n```\n    - group模块\n```bash\n# 创建stugp组，state不写默认present\nansible node1 -m group -a \"name=stugp\"\n# 删除组\nansible node1 -m group -a \"name=stugp state=absent\"\n``` \n    - yum_repository模块\n可以创建、修改yum源配置文件\n```bash\n# 新建一个yum源配置文件/etc/yum.repos.d/myyum.repo\nansible all -m yum_repository -a \"name=a description=aaa baseurl=yum源地址 gpgcheck=0\"\nansible all -m shell a \"cat /etc/yum.repos.d/a.repo\"\n# 无法实现同一个repo文件写两个yum源地址，只能一个yum源一个文件，且ansible会多生成一个async=1字段，启用并发下载\n```\n \n    - yum模块\n安装卸载升级软件包\n```bash\nstate：present（安装） absent（卸载） latest（升级）\nansible node1 -m yum -a \"name=unzip state=present\"\n```\n \n    - service模块\n服务管理模块，启动、关闭、重启服务等\nstate：started（开启） stopped（停止） restarted（重启） \nenabled=yes（开机自启）\n```bash\n# 开启服务\nansible node1 -m service -a \"name=httpd state=started\"\n# 开机自启并启动\nansible node1 -m service -a \"name=httpd enabled=yes state=started\"\n```\n \n    - 分区、逻辑卷相关模块\nstate：present（创建） absent（删除）\n        - 【part】模块：对硬盘分区\n```bash\n# 安装新collection，可以使用parted等模块\nansible-galaxy collection install http://server1.lab0.example.com/materials/community-general-6.3.0.tar.gz\n# 远程node2，对vdc进行分区，大小100M\nansible node2 -m parted -a \"device=/dev/vdc num=1 part_end=100Mib state=present\"\n# 第二个分区，要从第一个分区的end开始\nansible node2 -m parted -a \"device=/dev/vdc num=2 part_start=100Mib part_end=200Mib state=present\"\n# 删除第2个分区\nansible node2 -m parted -a \"device=/dev/vdc num=2 state=absent\"\n```\n\n        - 【filesystem】模块：用于格式化（创建文件系统）\nfstype 指定文件系统类型\ndev 指定要格式化的设备，可以是分区、逻辑卷\n```bash\n# 格式化为ext4文件系统类型\nansible node1 -m filesystem -a \"dev=/dev/vdc1 fstype=ext4\"\n# 再次格式化同一个分区为xfs文件系统类型\nansible node1 -m filesystem -a \"dev=/dev/vdc1 fstype=xfs force=true\"\n```\n\n        - 【mount】模块：用于挂载文件系统\npath 挂载点，若挂载点不存在，自动创建\nsrc 待挂载的设备\nfstype 文件系统类型\nstate=mounted 永久挂载\n```bash\n# 装包，9以上ansible基础包不包含mount，需下载额外的包（/var/www/html就是访问ip对应的物理路径）\nansible-galaxy collection install http://server1.lab0.example.com/materials/ansible-posix-1.5.1.tar.gz\n# 将/dev/vdc1分区挂载到/data\nansible node1 -m mount -a \"path=/data src=/dev/vdc1 fstype=xfs state=mounted\"\nssh node1 ; df -Th\n```\n\n        - 【lvg】模块：创建、删除卷组(vg)、修改卷组大小\n```bash\n# 先建个分区\nansible node1 -m parted -a \"dev=/dev/vdc num=2 part_start=100MiB part_end=200MiB state=present\"\n# 创建名为myvg的卷组，该卷组由/dev/vdc2组成\nansible node1 -m lvg -a \"vg=myvg pvs=/dev/vdc2 state=present\"\n# 删除卷组\nansible node1 -m lvg -a \"vg=myvg state=absent\"\n```\n\n        - 【lvol】模块：创建、删除逻辑卷（lv）、修改逻辑卷大小\n```bash\n# 创建逻辑卷,名为mylv，大小50M（从上边创建的myvg卷组中）\nansible node1 -m lvol -a \"lv=mylv vg=myvg size=50M\"\n# 删除逻辑卷\nansible node1 -m lvol -a \"lv=mylv state=absent force=true\"\n```\n \n    - firewalld模块\nstate：present enabled（添加） disabled（删除）\n```bash\n# 查看帮助文档（不在基础包里，在ansible-posix里）\nansible-doc firewalld\nzone：安全区域\npermanent：true永久生效 # 往区域里加规则需要加此参数，只改zone不需要\nimmediate：true立即生效\nservice：http协议\nport：端口\n# 添加、删除规则，放行http协议\nansible node1 -m firewalld -a \"state=enabled service=http permanent=yes immediate=yes\"\nansible node1 -m shell -a \"firewall-cmd --list-all | grep service\"\nansible node1 -m firewalld -a \"state=disabled service=http permanent=yes immediate=yes\"\n# 添加、删除规则，放行端口\nansible node1 -m firewalld -a \"state=enabled port=80/tcp permanent=yes immediate=yes\"\nansible node1 -m shell -a \"firewall-cmd --list-all | grep port\"\nansible node1 -m firewalld -a \"state=disabled port=80/tcp permanent=yes immediate=yes\"\n```\n \n    - setup模块\nansible_factes用于采集被管理设备的系统信息（内存、网卡）\t\n所有收集的信息都被保存在变量中\n每次执行playbook默认第一个任务就是Gathering Fact\n使用setup模块可以查看收集到的facts信息\n有父子关系使用.表示\n```bash\n# 查看收集到的信息\nansible test -m setup | less\n# 过滤关于内存的信息\nansible test -m setup -a \"filter=ansible_mem*\"\n# 过滤关于enp1s0网卡的信息\nansible test -m setup -a \"filter=ansible_enp1s0*\"\n# 查看主机名\nansible test -m setup -a \"filter=ansible_enp1s0*\"\n# 查看完全域名、完全主机名\nansible test -m setup -a \"filter=ansible_fqdn\"\n# 查看bios相关信息\nansible test -m setup -a \"filter=ansible_bios*\"\n\n# 常见变量：\nansible_enp1s0.ipv4.address   # enp1s0网卡的ip地址\nansible_hostname   # 主机名\nansible_memfree_mb   # 内存剩余大小，单位mb\nansible_fqdn   # 完整主机名\nansible_bios_version   # bios版本\nansible_devices.vda.size   # 第一块硬盘大小\nansible_devices.vda.partitions.vda1.size   # 第一块硬盘第一个分区大小\nansible_lvm.lvs.root.size_g   # 逻辑卷root的大小\nansible_kernel   # 内核版本信息\n```\n \n    - debug模块\n```bash\n# 查看node1主机有关的魔法变量，如果该任务写成剧本，由于剧本会自动收集普通变量，所以到时还会看到除了魔法变量之外的普通变量，如ip、内存大小等\nansible node1 -m debug -a \"msg={{hostvars.node1}}\"\n```\n \n    - get_url模块\n```bash\n# 从网络下载文件\nansible node1 -m get_url -a \"url=http://server dest=\"\n```\n\n \n- 【ansible playbook】\nansible playbook：剧本\n①将经常需要执行的任务写入一个文件（剧本）\n②剧本中可以包含多个任务\n③剧本写好后，随时根据剧本，执行相关的任务命令\n④playbook剧本要求按照yaml格式编写\n⑤适合执行周期性经常执行的复杂任务\n\n语法格式：\n```yaml\n- yaml格式\n- 剧本文件中由1个或多个play组成\n- 每个play可包含：\n    - hosts（主机）\n    - tasks（任务）\n    - variables（变量）\n    - roles（角色）\n    - handlers（触发器）\n- 使用ansbile-playbook命令运行\n```\n\nvim写yaml小技巧\n```bash\nvim ~/.vimrc # 只对对应用户有效\nset nu ai ts=2 et cuc\n# nu：行号\n# ai：自动缩进\n# ts：一个table等于几个空格\n# et：把table转成空格\n# cuc：光标列对齐\n```\n \n\n- playbook格式\n```bash\n# 配置yum源、装包\n# 另开一个窗口：ansible-doc yum_repository # 搜EXAMPLES，直接粘过来修改\nvim yum_install.yaml\n---\n- hosts: all\n  tasks:\n  - name: Add multiple repositories into the same file（1/2） # 可不写，不写直接写下边的模块名\n    yum_repository:\n      name: AppStream\n      description: AppStream\n      baseurl: https://server1.lab0.example/rhel9/AppStream\n      gpgcheck: no\n  - name: Add multiple repositories into the same file（2/2） # 可不写，不写直接写下边的模块名\n    yum_repository:\n      name: AppStream\n      description: AppStream\n      baseurl: https://server1.lab0.example/rhel9/AppStream\n      gpgcheck: no\n# 以上算1个play，再写play要顶格写，也可用name加描述信息\n# 另开一个窗口：ansible-doc yum # 搜EXAMPLES，直接粘过来修改\n- name: install package # 可写可不写，不写就得- hosts\n  hosts: webserver\n  tasks:\n  - name: install a list package\n    yum:\n      name:\n      - httpd\n      - mariadb\n      - mariadb-server\n  - name: install a group package\n    yum:\n      name: \"@Development tools\"\n  - name: update software\n    yum:\n      name: \"*\"\n      state: latest\n\nansible-playbook yum_install.yaml\nansible webserver -m shell -a \"rpm -q httpd mariadb mariadb-server\"\nansible webserver -m shell -a \"dnf grouplist\"\n```\n\n- debug模块\n可以显示变量的值，可以辅助排错\n```yaml\n\tvar：引用变量不需要{{}}\n\tmsg：引用变量需要{{}}\n```\n```bash\nvim debug.yaml\n---\n- hosts: test\n  tasks:\n  - debug:\n      var: ansible_all_ipv4_addresses\n  - debug:\n      msg: \"主机名是:{{ ansible_hostname }}\"\n  - debug:\n      msg: \"总内存大小是{{ ansible_memtotal_mb }}\"\n\nansible-playbook debug.yml\n```\n- template模块\ncopy模块可以将一个文件拷贝给远程主机，但是希望每个文件内容都不一样，需要用到template\n如何给所有web主机拷贝index.html内容是各自的IP地址、含有变量\nansible可以利用jinja2模板引擎读取变量\n```text\n\t在playbook中调用变量，也是jinja2的功能\n\tjinja2模块的表达式包含在分隔符{{}}内\n```\n使用template模块将含有变量的文件上传到webserver组中的主机\n```bash\nmkdir template\n# 写一个含有变量的文件\nvim template/index.html\nWelcome to {{ ansible_hostname }}\n# \nvim template.yml\n---\n- hosts: webserver\n  tasks: \n  - name: install httpd\n    yum:\n      name: httpd\n  - name: use template module\n    template:\n      src: ~/ansible/template/index.html\n      dest: /var/www/html/index.html   # httpd服务默认网页路径\n\nansible-playbook template.yml\nansible webserver -m shell -a \"cat /var/www/html/index.html\"\n\n# jin2写for循环示例：\n{% for i in groups.all %}\n{{ hostvars[i].ansible_enp1s0.ipv4.address }} {{ hostvars[i].ansible_fqdn }} {{ hostvars[i].ansible_hostname }}\n{% endfor %}\n```\n    - replace模块\n```bash\nvim /root/hardware.txt\nhostname=inventoryhostname\nmem=memory_in_MB\nbios=BIOS_version\nvdasize=disk_vda_size\nvdbsize=disk_vdb_size\n\nvim replace.yml\n---\n- hosts: all\n  tasks:\n  - replace:\n      path: /root/hardware.txt\n      regexp: inventoryhostname\n      replace: \"{{ inventory_hostname }}\"\n  - replace:\n      path: /root/hardware.txt\n      regexp: disk_vda_size\n      replace: \"{{ ansible_devices.vda.size }}\"\n  - replace:\n      path: /root/hardware.txt\n      regexp: disk_vdb_size\n      replace: \"{{ ansible_devices.vdb.size if ansible_devices.vdb.size is defined else 'NONE' }}\"\n```\n \n\n\n- ansible容器运行playbook\n```bash\n# 1安装navigator软件包\nsudo dnf -y install ansible-navigator\n# 2编写navigator下载镜像的配置文件，要放到家目录下\nvim ~/.ansible-navigator.yml\n---\nansible-navigator:\n  execution-enviroment:\n    image: registry.lab0.example.com:5000/ee-supported-rhel8:latest\n    pull:\n      policy: missing   # 如果使用镜像时没有就下载，有就不下载\n# 3修改配置文件，方法和之前的podman一样\nsudo vim /etc/containers/registries.conf\nunqualified-search-registries = [\"registry.lab0.example.com:5000\"]\n[[registry]]\ninsecure = true\nlocation = \"registry.lab0.example.com:5000\"\n# 4查看镜像，yaml中定义的image没有就下载，有就跳过\nansible-navigator images   # esc退出\n<==>\npodman images\n# 5临时在容器中运行剧本\nansible-navigator run debug.yml -m stdout\n```\n\n【ansible变量】\n- inventory变量（主机清单文件变量）\n在主机清单配置文件中定义变量，可以针对主机或组\n```bash\nvim hosts\n[test]\nnode1 myvar1=\"hello the world\" myvar2=\"content\"   # 在node1主机中定义了两个变量\n[webserver]\nnode[3:4]\n[webserver:vars]   # 主机组变量\nyourname=\"jade\"\n\n# 写playbook调用\nvim var.yaml\n---\n- hosts: node1\n  tasks:\n  - shell: echo \"{{ myvar1 }}\" > /tmp/\"{{ mywar2 }}\"\n- hosts: webserver\n  tasks:\n  - user:\n      name: \"{{ yourname }}\"\n\nansible node1 -m shell -a \"ls /tmp\"\nansible webserver -m shell -a \"id jade\"\n```\n- 魔法变量\n    - ansible的内置变量\n```yaml\n# 常用变量：\ninventory_hostname   # 清单主机名\nhostvars   # 包含被控制主机的所有变量\nhostvars.node1   # 只调用node1主机所有变量\nhostvars.node1.group_names   # 显示node1所在组的名字\ngroups   # 所有主机以及组信息\ngroups.all   # 所有被控制主机主机名\ngroups.test01   # 显示test01组里的所有主机名\ngroups_names   # 当前运行任务的主机所在的组的名字\n\n# 查看node1主机有关的魔法变量，如果该任务写成剧本，由于剧本会自动收集普通变量，所以到时还会看到除了魔法变量之外的普通变量，如ip、内存大小等\nansible node1 -m debug -a \"msg={{hostvars.node1}}\"\n```\n- playbook变量\n在playbook中定义变量\n使用vars关键词\n```bash\nvim playbook_var.yml\n---\n- hosts: test\n  vars:\n    iname: heal\n    ipass: '12345'   # 密码必须是string，需要引号\n  tasks:\n  - user:\n      name: \"{{iname}}\"\n      password: \"{{ ipass | password_hash('sha512') }}\"\n\nansible-playbook playbook_var.yml\nansible test -m shell -a \"id heal\"\n```\n- 变量文件\n单独定义个变量文件\n在playbook中使用vars_files调用该变量文件\n优先级是最高的\n```bash\nvim variables.yml\n---\niname: cloud\nipass: '123456'\n\nvim file_var.yml\n---\n- hosts: test\n  vars_files: variables.yml   # 相对路径需要变量yaml和playbookyaml在同个目录\n  tasks:\n  - name: create user.\n    user:\n      name: \"{{ iname }}\"\n      password: \"{{ ipass | password_hash('sha512') }}\"\n\nansible test -m shell -a \"id cloud\"\n```\n\n【ansible高级语法】\n- handlers\n可以通过handlers定义一组任务\n仅当某个任务触发（notify）handlers时才执行相应的任务\n如果有多个notify触发执行handlers任务，也仅执行一次\n仅当任务的执行状态为changed时handlers任务才执行\nhandlers任务在所有其他任务都执行后才执行\n```bash\nvim handlers.yml\n---\n- hosts: test\n  tasks:\n  - file: \n      path: /tmp/parents/subdir\n      state: directory\n    notify: touch file   # 要和handlers的name值对应\n  handlers:   # 当notify所在task change，handlers才会执行，基于幂等性，success或其他不会执行\n  - name: touch file   # 要和notify值对应\n    file:\n      path: /tmp/parents/subdir/new.txt\n      state: touch\n```\n\n- when条件判断\n条件为真时执行\n```text\n常见条件操作符：== != > >= < <=\n可用and or\nwhen表达式中调用变量不使用{{}}，直接写变量名\n```\n```bash\n# 远程主机剩余内存不足800M，则关闭NetworkManager服务\n# 变量名可通过setup模块进行查找\nvim when.yml\n---\n- hosts: test\n  tasks:\n  - service:\n      name: NetworkManager\n      state: stopped\n    when: ansible_memfree_mb < 800\n\n# 多个条件\nvim when-multi.yaml\n---\n- hosts:\n  tasks:\n  - file:\n      path: /tmp/jadewhen.txt\n      state: touch\n    when: > # >换行符，不保留换行符，也可直接写一行空格分隔\n      ansible_distribution == \"RedHat\"\n      and\n      ansible_distribution_major_version == \"9\"\n# when成立 success执行；不成立 skipping跳过\n```\n\n- fail模块\n任务执行失败则终止任务\n```bash\nansible node1 -m setup -a \"filter=ansible_dev*\"\nvim fail.yml\n---\n- hosts: all\n  tasks:\n  - fail:\n      msg: \"vdc不存在设备里，终止任务\"\n    when: \"'vdc' not in ansible_devices\"\n```\n \n\n\n- block任务块\n使用block可以将多个任务合并为一个组\n可以将整个block任务组，一起控制是否要执行\n```bash\n# block结合when使用时，当条件成立，执行一组任务\nvim block.yaml\n---\n- hosts: test\n  tasks:\n  - block:\n    - yum:\n        name: mysql-server\n        state: present\n    - service:\n        name: mysqld\n        state: started\n    when: ansible_distribution == \"RedHat\"\n\nansible-playbook block.yaml\nansible test -m shell -a \"rpm -q mysql-server ; systemctl status mysqld\"\n# 常用关键词：\n【rescue】 定义block任务失败时要执行的其他任务\n【always】 定义无论block任务是否成功，都要执行的任务\n```\n```bash\nvim block-rescue-always.yml\n---\n- hosts: test\n  tasks:\n  - block:\n    - file:\n        path: /tmp/notexist/block.txt\n        state: touch\n    rescue:   # block失败时执行\n    - file:\n        path: /tmp/rescue.txt\n        state: touch\n    always:   # 成功与否，都会执行\n    - file:\n        path: /tmp/always.txt\n        state: touch\n```\n- loop循环\n相当于for\n循环用到的变量名是固定的：item\n```bash\nvim simple-loop.yaml\n---\n- hosts: test\n  task:\n  - file:\n      path: /tmp/{{item}}\n      state: directory\n    loop:\n    - School\n    - Legend\n    - Life\n\nvim complex-loop.yaml\n---\n- hosts: test\n  tasks:\n  - user:\n      name: \"{{item.iname}}\"\n      password: \"{{item.upass | password_hash('sha512')}}\"\n    loop:\n    - { iname: 'tem', upass: '123456'}\n    - { iname: 'amy', upass: '654321'}\n\nansible-playbook complex-loop.yaml\nansible test -m shell -a \"id term;id amy\"\n```\n【ansible角色】\n在实际生产环境中，为实现不同功能会编写大量playbook，而且每个playbook还可能会调用其他文件（如变量文件）\n对于海量的、无规律的文件，管理较麻烦\nansible从1.2版本开始支持roles\nroles是管理ansible文件的一种规范（目录结构）\nroles会按照标准的规范，自动到特定的目录和文件中读取数据\n\nroles规范的目录结构\n\ndefaults/main.yml：定义变量的缺省值，优先级较低\nfiles目录：存储静态文件的目录\nhandlers/main.yml：定义handlers\nmeta/main.yml：作者、版本等描述信息\nREADME.md：整个role的描述信息\ntasks/main.yml：定义任务\ntemplates目录：存放动态数据文件的地方（模版文件）\nvars/main.yml：定义变量，优先级高\n\nroles应用\n```bash\n# 配置，在defaults下添加roles_path行，自定义role存放位置\nvim ansible.cfg\n[defaults]\ninventory=./hosts\nremote_user=alice\nrole_path=./roles   # 定义角色目录位置\n[privilege_escalation]\nbecome=True\nbecome_method=sudo\nbecome_user=root\nbecome_ask_pass=False\n```\n    - 手工创建角色\n```bash\n# 创建角色相关目录，roles是配置文件中指定的存放角色总目录，http是创建的角色，tasks是存放角色任务的目录\nmkdir -p roles/http/tasks\nvim roles/http/tasks/main.yml\n---\n- yum:\n    name: httpd\n- debug:\n    msg: ok\n\n# 编写playbook调用角色\nvim myrole.yml\n---\n- hosts: test\n  roles:\n  - http   # 会找roles下的http下的tasks的main.yml\n```\n\n    - 使用命令创建角色\n```bash\nansible-galaxy命令可以创建、管理自己的roles\n# 初始化创建一个role，名为issue\nansible-galaxy init ~/ansible/roles/issue\n# 把控制端本地的文件拷贝到被管理主机\n# 如果拷贝的是常量文件，则把文件放到files目录下\n# 如果拷贝的是变量文件，则放到templates下\n\n# 定义issue模版文件\nvim ~/ansible/roles/issue/templates/issue.j2\nthis is the system {{ansible_hostname}}\ncontact to {{admin}}   # 自定义变量\n\n# 定义刚才j2文件中使用的自定义变量\nvim roles/issue/vars/main.yml\nadmin: jade@cloud.cn\n\n# 定义任务：拷贝模版文件\nvim roles/issue/tasks/main.yml\n---\n- template:\n    src: issue.j2   # 不需要写绝对路径，只写文件名，roles会自动找\n    dest: /etc/issue\n\n# 写playbook调用issue角色\nvim issue.yml\n---\n- hosts: test\n  roles:\n  - issue\n\n# 运行\nansible-playbook issue.yml\nansible test -m shell -a \"cat /etc/issue\"\n```\n\n    - 使用网络下载安装角色\ngalaxy.ansible.com/ui/ 可以看到别人写好的角色\n```bash\nvim roles.yml\n---\n- name: myphp   # 安装的角色名\n  src: http://172.25.0.254/roles/myphp.tar   # 下载的角色路径\n\n# 安装网上下载的角色，-r 指定下载的角色文件，默认安装路径由配置文件中roles_path决定\nansible-galaxy install -r roles.yml\nls ~/ansible/roles\n```\n \n    - 安装系统自带角色\n```bash\n# 安装系统自带角色\ndnf -y install rhel-system-roles\n# 查看rhel-system-roles安装清单\nrpm -ql rhel-ssytem-roles\n# 拷贝角色\ncp -r /usr/share/ansible/roles/rhel-system-roles.timesync/ roles\n# 参考帮助文档编写剧本文件，时间同步 timesync\ncat roles/rhel-system-roles.timesync/README.md\n\nvim timesync.yml\n---\n- hosts: test\n  vars:\n    timesync_ntp_servers:\n    - hostname: 192.25.0.254\n      iburst: yes\n  roles:\n  - rhel-system-roles.timesync\n\n# 执行\nansible-playbook timesync.yml\nansible test -m shell -a \"chronyc sources -v\"\n```\n \n【ansible vault】\nansible有时需要访问一些敏感数据，如密码、key等\n使用ansible-vault可以加密或解密数据\n--encrypt：加密\n--decrypt：解密\n--view：查看\n--rekey：修改密码\n```bash\n# 新建测试文件\nvim hello.txt\nHello The world\n# 加密文件\nansible-vault --help\nansible-vault encrypt hello.txt\n# 查看加密文件\nansible-vault view hello.txt\n# 解密\nansible-vault decrypt hello.txt\n# 修改密码\nansible-vault rekey hello.txt\n\n# 用密码文件做加密解密，防止忘记密码\nvim pass\n123456\nansible-vault encrypt --vault-id=pass hello.txt\nansible-vault decrypt --vault-id=pass hello.txt\n\n# playbook做加密解密\nvim user-vault.yml\n---\n- hosts: test\n  tasks:\n  - user:\n      name: jerry\n      password: \"{{ '12345' | password_hash('sha512') }}\"\nansible-vault encrypt user-vault.yml\n# 使用--ask-vault-password运行playbook\nansible-playbook user-vault.yml --ask-vault-password\n```"},{"title":"markdown常用语法备忘","url":"/2025/04/02/markdown常用语法备忘/","content":"# 一级标题 缩略栏是居中的大标题\n## 二级标题 二级好看，用二级当一级\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n####### 没有七级，七级是正文  \n```text\n# 一级标题 缩略栏是居中的大标题\n## 二级标题 二级好看，用二级当一级\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n####### 没有七级，七级是正文 \n```\n1. 有序列表一\n2. 有序列表二\n```text\n1. 有序列表一\n2. 有序列表二\n```\n- 无序列表\n- 无序列表\n+ test3\n+ test4\n* test5\n* test6\n```text\n- 无序列表\n- 无序列表\n+ test3\n+ test4\n* test5\n* test6\n```\n---\n```text\n分割线\n---\n```\n> 引用\n```text\n> 引用\n```\n[行内式链接](https:fay.net.cn)  \n[参数式链接]: https://fay.net.cn  \n![本地头像](./reimu.png)\n```text\n[行内式链接](https:fay.net.cn)  \n[参数式链接]: https://fay.net.cn  \n![本地头像](./reimu.png)\n```\n| name | desc |\n|:------:|------|\n| a | b |\n```text\n| name | desc |\n|:------:|------|\n| a | b |\n```\n_斜体_  \n__粗体__  \n___粗斜体___  \n\\*反斜杠转义\n~~删除线~~\n<u>下划线</u>\n脚注[^1]\n[^1]: 脚注1内容\n```text\n_斜体_  \n__粗体__  \n___粗斜体___  \n\\*反斜杠转义\n~~删除线~~\n<u>下划线</u>\n脚注[^1]\n[^1]: 脚注1内容\n```\n```c++\nclass Solution {\npublic:\n    vectio<int> res,left,right;\n}\n```"},{"title":"博客搭建hexo+github+个人域名","url":"/2025/03/27/博客搭建hexo-github-个人域名/","content":"\n## 安装nodejs\n- __下载__\n[nodejs官网]: https://nodejs.org/en/download/\n根据电脑系统、架构下载对应版本\n- __安装__\n解压后安装，除安装地址外、其他选项默认即可\n检查是否安装成功：\n【win+r】输入【cmd】回车（打开命令行）\n![](博客搭建hexo-github-个人域名/win_r-cmd.png)\n```bash\n# 如无信息可到cd到对应安装目录执行\nnode -v\n```\n如下输出版本号即安装成功\n![](博客搭建hexo-github-个人域名/nodejs_version.png)\n- __配置环境__\n1. 到nodejs安装目录下，和node.exe同级，新建两个文件夹【node_global】和【node_cache】\n2. 以管理员身份运行cmd\n```bash\nnpm config set prefix \"刚刚创建的node_global路径\"\nnpm config set cache \"刚刚创建的node_cache路径\"\n```\n3. 配置系统环境变量\n【win+r】输入【sysdm.cpl】回车（打开系统属性）\n【系统属性】-【高级】-【环境变量】-【系统变量】-【Path】-【新建】\n```yaml\n变量名：NODE_PATH\n变量值：D:\\develop\\nodejs\\node_global\\node_modules\n```\n配置后【node_global】下会自动生成【node_modules】，如未出现，手动创建\n4. 配置用户环境变量\n【win+r】输入【sysdm.cpl】回车（打开系统属性）\n【系统属性】-【高级】-【环境变量】-【用户变量】-【Path】-【编辑】\n将原本的默认【C:\\Users\\哔\\AppData\\Roaming\\npm】修改为【node_global】的绝对路径\n5. 配置系统环境变量\n【系统变量】-【Path】-【编辑】\n【新建】-输入【%NODE_PATH%】-确认\n6. 测试\n以管理员身份运行cmd\n```bash\n# 检查是否正常输出刚才配置的路径\nnpm config get prefix\nnpm config get cache\n# 全局安装一个最常用的express模块测试\nnpm install express -g # -g代表全局安装\n```\n## 安装git\n- __下载安装__\n[git国内官网]: https://git-scm.com/\n根据电脑系统、架构下载对应版本，安装\n- __检查__\n```bash\ngit --version\n# 输出对应版本号则为安装成功\n# 在桌面或任意文件夹内右键会多两个选项：【Git GUI Here】【Git Bash Here】\n```\n## 安装hexo\n- __下载安装__\n创建文件夹，日后博客相关文件都会保存在此，例【d:\\develop\\hexo】，然后进入hexo目录，【右键】-【Git Bash Here】\n```bash\nnpm install hexo-cli -g\nnpm install hexo-deployer-git --save\n# 初始化hexo\nhexo init\n```\n== 后边的命令默认在hexo文件夹下执行 ==\n- __更换喜欢的主题__\n[hexo主题官网点击此处：Themes | Hexo](https://hexo.io/themes/)\n找到喜欢的主题，git clone到theme下\n修改外层【_config.yml】中的theme值为刚刚克隆的主题文件夹名，我这里用的主题是[hexo-theme-reimu](https://github.com/D-Sketon/hexo-theme-reimu)  \n```yaml\ntheme: reimu\n```\n- __本地运行__\n```bash\n# 启动\nhexo clean & hexo g & hexo server\n# 访问4000端口，发现已生成博客\nhttp://localhost:4000\n```\n## 将本地博客部署到GitHubPages\n1. 注册登录github账号，根据官网指引绑定ssh秘钥，在github中添加公钥\n2. github创建仓库，仓库名格式一定为\"用户名.github.io\"，后期访问需要通过这个域名访问，设置公开仓库\n![](博客搭建hexo-github-个人域名/github_repo_create.png)\n3. 配置github仓库地址到config里\n复制ssh的git地址\n![](博客搭建hexo-github-个人域名/git_clone.png)\n修改外层【_config.yml】里的deploy下的字段\n![](博客搭建hexo-github-个人域名/config_deploy.png)\n4. 部署到github\n```bash\nnpm install hexo-deployer-git --save\nhexo g -d\n```\n5. 访问博客地址\n```yaml\nhttps://自己的用户名.github.io\n```\n比如我的是(https://jade-xyy.github.io)\n## 写文章\nhexo下的【source\\_posts】文件夹是用来保存文章的\n```bash\n# 生成新文章\nhexo new post \"文章标题\"\n# 找到对应文章的md文件，用markdown语法编辑文章后发布，重新访问即可看到\nhexo g # 生成网页\nhexo s # 本地预览\nhexo d # 推送到服务器\n```\n## 绑定个人的私有域名\n- __首先需要购入一个私有域名__\n我是在阿里云购买的域名\n- __配置dns解析__\n配置5条记录\n```yml\n1条【CNAME】的，主机记录 www ，记录值填上边的github访问地址（自己的用户名.github.io）\n4条【A】的，主机记录 @ ，记录值为以下\n185.199.108.153\n185.199.109.153\n185.199.110.153\n185.199.111.153\n```\n- __创建域名跳转文件__\n在仓库根目录下，创建CNAME文件，内容为购买的域名，例如我自己的\n![](博客搭建hexo-github-个人域名/github_cname.png)\n到github仓库的【Settings】-【Pages】中，配置域名\n![](博客搭建hexo-github-个人域名/github_setting.png)\n另外还得在 /source 下创建CNAME文件，防止hexo clean时，public下的CNAME被覆盖消失\n![](博客搭建hexo-github-个人域名/source_cname.png)\n__访问个人域名，全部完成！！！__"},{"title":"Hello World","url":"/2025/03/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]